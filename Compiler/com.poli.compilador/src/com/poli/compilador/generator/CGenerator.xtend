/*
 * generated by Xtext 2.12.0
 */
package com.poli.compilador.generator

import com.poli.compilador.c.ArithExp
import com.poli.compilador.c.ArrayAccess
import com.poli.compilador.c.BreakCmd
import com.poli.compilador.c.Command
import com.poli.compilador.c.ContinueCmd
import com.poli.compilador.c.DeclCmd
import com.poli.compilador.c.Declaration
import com.poli.compilador.c.Definition
import com.poli.compilador.c.DoWhileCmd
import com.poli.compilador.c.FalseLit
import com.poli.compilador.c.FieldAccess
import com.poli.compilador.c.ForCmd
import com.poli.compilador.c.FuncCall
import com.poli.compilador.c.Function
import com.poli.compilador.c.IfCmd
import com.poli.compilador.c.IntLit
import com.poli.compilador.c.LogicExp
import com.poli.compilador.c.Parenteses
import com.poli.compilador.c.PointerExp
import com.poli.compilador.c.PostfixOp
import com.poli.compilador.c.PrefixOp
import com.poli.compilador.c.Program
import com.poli.compilador.c.RelExp
import com.poli.compilador.c.ReturnCmd
import com.poli.compilador.c.Struct
import com.poli.compilador.c.SwitchCmd
import com.poli.compilador.c.Term
import com.poli.compilador.c.TrueLit
import com.poli.compilador.c.Var
import com.poli.compilador.c.VarCmd
import com.poli.compilador.c.WhileCmd
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import com.poli.compilador.c.PrintCmd
import com.poli.compilador.validation.Validator
import com.poli.compilador.c.StrLit
import java.util.Stack
import com.poli.compilador.c.Expression
import com.poli.compilador.c.Assignment
import com.poli.compilador.c.VarDecl
import java.util.HashMap
import org.eclipse.emf.common.util.EList
import java.util.ArrayList
import java.util.List

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class CGenerator extends AbstractGenerator {
	
	public int label 						// unique label
	public int suffix 						// unique suffix
	public int index 						// unique index
	public int localSize 					// local variables size in bytes
	public Stack<String> fName 				// function name
	public Stack<Pair<String, String>> loops	// start label, end label
	public HashMap<String, String> globals 	// real Id, unique Id
	public HashMap<String, Integer> locals 	// real Id, heap offset 
	public HashMap<String, Integer> params 	// real Id, register $a0-$a3
	
	def init() {
		this.label 		= 0
		this.suffix		= 0
		this.index		= 0
		this.localSize	= 0
		this.fName		= new Stack
		this.loops		= new Stack
		this.globals		= new HashMap
		this.locals		= new HashMap
		this.params		= new HashMap
	}

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var Program p	= resource.allContents.filter(Program).head
		var filename 	= resource.URI.lastSegment.split("\\.").get(0)
		
		if (p === null) {return}
		
		this.init()
		this.calculateLocals(resource, p)
		
	    fsa.generateFile(filename+".asm", p.compile)
	}

	def compile(Program P) 
	'''

		«FOR D : P.definition»
		    «definition(D)»
		«ENDFOR»
		exit:
			li $v0, 10
			syscall
	'''
	
	def definition(Definition D) {
		
		switch D {
			case (D instanceof Function): 	function(D as Function)
			case (D instanceof Declaration):	declaration(D as Declaration)
			case (D instanceof Struct): 		struct(D as Struct)
		}
		
	}
	
	def struct(Struct S) {
		
	}
	
	def declaration(Declaration D) {
		
		if (D instanceof VarDecl) {
			var mips 	= ''''''
			this.suffix++
			val vName	= D.name + suffix
			globals.put(D.name, vName)
			
			if (D.tipo.tipo == 'string') {
				var content = if (D.^val === null) "" else (D.^val.exp as StrLit).^val
				
				mips = 
				'''
				.data
				_«vName»: .asciiz "«content»"
				
				''' 
				
				return mips
			}
			
			var size = 4
			if (D.tipo.exp !== null) {
				val arrIdx 	= D.tipo.exp
				val arrSize	= (arrIdx as IntLit).^val
				
				size = arrSize*4;
			}
			
			mips =
			'''
			.data
			.align 2
			_«vName»: .space «size»
			«IF D.^val !== null»
				.text
				«assign(D.^val)»
				«pop('t9')»
				sw		$t9, _«vName»
			«ENDIF»
			
			'''
			
			return mips
		}

	}
	
	def function(Function F) {
		fName.push(F.name)
		globals.put(F.name, F.name)
		val paramSize = getParamSize(F.params)
		
		var mips = 
		'''
		.text
		.align 2
		«IF F.name.equals('main')»
		.globl main
		«F.name»:
		«ELSE»
		_«F.name»:
		«ENDIF»
			«functionEntry(paramSize)»
			«FOR C : F.commands»
				«command(C)»
		    «ENDFOR»
		    «functionExit(paramSize)»
		
		'''
		return mips
	}
	
	def CharSequence command(Command C) {
		
		switch C {
			case C instanceof PrintCmd: 		printCommand(C as PrintCmd)
			case C instanceof IfCmd: 		ifCommand(C as IfCmd)
			case C instanceof WhileCmd: 		whileCommand(C as WhileCmd)
			case C instanceof ForCmd: 		forCommand(C as ForCmd)
			case C instanceof SwitchCmd: 	switchCommand(C as SwitchCmd)
			case C instanceof DoWhileCmd: 	doWhileCommand(C as DoWhileCmd)
			case C instanceof VarCmd:		varCommand(C as VarCmd)
			case C instanceof BreakCmd: 		breakCommand(C as BreakCmd)
			case C instanceof ContinueCmd:	continueCommand(C as ContinueCmd)
			case C instanceof ReturnCmd: 	returnCommand(C as ReturnCmd)
			case C instanceof DeclCmd: 		declCommand(C as DeclCmd)
		}
	}
	
	def switchCommand(SwitchCmd C) {
		var mips = ''''''
		var Stack<String> caseLabel = new Stack
		var end = nextLabel+"_endswitch"
		loops.push(new Pair("", end))
		
		mips +=
		'''
		«expression(C.exp)»
		«pop('t0')»
		«FOR cs : C.cases»
		«val label = caseLabel.push(nextLabel+"_switch")»
		«var tipo = Validator.tipode(cs.^val, null)»
		«IF tipo == Validator.Tipo.INT»
		beq $t0, «(cs.^val as IntLit).^val», «label»
		«ELSEIF tipo == Validator.Tipo.BOOL && cs.^val instanceof TrueLit»
		bne $t0, $0, «label»
		«ELSEIF tipo == Validator.Tipo.BOOL && cs.^val instanceof FalseLit»
		beq $t0, $0, «label»
		«ENDIF»
		«ENDFOR»
		«val defLabel = nextLabel+"_default"»
		j «defLabel»
		
		«{caseLabel = orderStack(caseLabel); ""}»
		«FOR cs : C.cases»
		«caseLabel.pop»:
			«FOR cmd : cs.commands»
				«command(cmd)»
			«ENDFOR»
		«ENDFOR»
		«FOR defCmd : C.defaultCmds»
		«defLabel»:
			«command(defCmd)»
		«ENDFOR»
		«end»:
		'''
		
		loops.pop
		return mips
	}
	
	def declCommand(DeclCmd C) {
		var mips 	= ''''''
		val vName	= C.^val.name
		val decl 	= C.^val
		locals.put(vName, index)
		
		if (decl instanceof VarDecl) {
			mips =
			'''
			# «vName»
			«IF decl.^val !== null»
			«expression(decl.^val.exp)»
			«pop('t7')»
			sw		$t7, -«index+8»($fp)
			
			«ENDIF»
			'''
			
			if(decl.tipo.exp !== null) {
				index += (decl.tipo.exp as IntLit).^val * 4
			} else {
				index += 4;
			}
		}
		
		return mips
	}
	
	def breakCommand(BreakCmd C) {
		val endloop = (loops.peek).value
		
		val mips = 
		'''
			j «endloop»
			
		'''
		
		return mips
	}
	
	def continueCommand(ContinueCmd C) {
		val startloop = (loops.peek).key
		
		val mips = 
		'''
			j «startloop»
			
		'''
		
		return mips
	}
	
	def forCommand(ForCmd C) {
		var mips 	= ''''''
		val start	= nextLabel+"_for"
		val end		= nextLabel+"_endfor"
		loops.push(new Pair(start, end))
	    
	    mips +=
	    '''
		«assign(C.initAsg)»
		«store(C.init)»
		«start»:
		«expression(C.exp)»
		«pop('t0')»
		beq		$t0, $0, «end»
		«FOR c : C.commands»
			«command(c)»
		«ENDFOR»
		«IF C.incAsg !== null»
		«assign(C.incAsg)»
		«store(C.inc)»
		«ELSE»
		«expression(C.inc)»
		«ENDIF»
		j «start»
		«end»:
		
		'''
		
		loops.pop
		return mips
	}
	
	def whileCommand(WhileCmd C) {
		var mips 	= ''''''
		val start	= nextLabel+"_while"
		val end		= nextLabel+"_endwhile"
	    loops.push(new Pair(start, end))
	    
	    mips +=
	    '''
		«start»:
		«expression(C.exp)»
		«pop('t0')»
		beq		$t0, $0, «end»
		«FOR c : C.commands»
			«command(c)»
		«ENDFOR»
		j «start»
		«end»:
		
		'''
		
		loops.pop
		return mips
	}
	
	def doWhileCommand(DoWhileCmd C) {
		var mips 	= ''''''
		val start	= nextLabel+"_dowhile"
		val end		= nextLabel+"_enddowhile"
		loops.push(new Pair(start, end))
	    
	    mips +=
	    '''
		«start»:
		«FOR c : C.commands»
			«command(c)»
		«ENDFOR»
		«expression(C.exp)»
		«pop('t0')»
		bne		$t0, $0, «start»
		end
		
		'''
		
		loops.pop
		return mips
	}
	
	def CharSequence printCommand(PrintCmd C) {
	    var mips		= ''''''
	    val tipo 	= Validator.tipode(C.exp, null)
	    
	    mips +=
	    '''
	    «expression(C.exp)»
	    «pop('a0')»
	    «IF tipo == Validator.Tipo.INT || tipo == Validator.Tipo.BOOL || tipo === null»
	    li		$v0, 1
	    «ELSEIF tipo == Validator.Tipo.STR»
	    li		$v0, 4
	    «ENDIF»
	    syscall
	    
	    '''
	    
	    return mips
	}
	
	def CharSequence ifCommand(IfCmd C) {
		var mips 	= ''''''
		val label	= nextLabel
		val falsel 	= label+'_FALSE'
		val truel 	= label+'_TRUE'
	    
	    mips +=
	    '''
		«expression(C.exp)»
		«pop('t0')»
		beq		$t0, $0, «falsel»
        «FOR tc : C.trueCommands»
    			«command(tc)»
        «ENDFOR»
		j «truel»
		
		«falsel»:
		«IF C.falseCommands !== null»
			«FOR fc : C.falseCommands»
				«command(fc)»
			«ENDFOR»
		«ENDIF»
		«truel»:
		
        '''
 
	   return mips
	}
	
	def returnCommand(ReturnCmd C) {
		var mips = ''''''
		
		mips += 
		'''
		«IF C.exp !== null»
			«expression(C.exp)»
			«pop('v0')»
		«ENDIF»
		j «fName.peek»_return
		
		'''
		return mips
	}
	
	def varCommand(VarCmd V) {
		var mips = ''''''
		
		if (V.asg !== null) {
			mips +=
				'''
				«assign(V.asg)»
				«IF V.lval instanceof ArrayAccess»
				«storeArray(V.lval as ArrayAccess)»
				«ELSE»
				«store(V.lval)»
				«ENDIF»
				'''
			return mips
		}

		mips +=
		'''
		«expression(V.lval)»
		«pop('v0')»
		
		'''
		
		return mips
	}

	
	def CharSequence assign(Assignment A)
	'''
		«expression(A.exp)»
	'''
	
	def CharSequence expression(Expression E) {
		var mips = ''''''
		
		if (E instanceof ArithExp) {
			if (E.op.equalsIgnoreCase('+')) {
				mips += arithExp(E, 'add')
			}
				
			if (E.op.equalsIgnoreCase('-')){
				mips += arithExp(E, 'sub')
			}
			
			return mips
		}
		
		if (E instanceof Term) {
			if (E.op.equalsIgnoreCase('*')){
				mips += termExp(E, 'mul')
			}
			
			if (E.op.equalsIgnoreCase('/')){
				mips += termExp(E, 'div')
			}
			
			return mips
		}
		
		if (E instanceof RelExp) {
			if (E.op.equalsIgnoreCase('>')){
				mips += relExp(E, 'sgt')
			}
			
			if (E.op.equalsIgnoreCase('>=')){
				mips += relExp(E, 'sge')
			}
			
			if (E.op.equalsIgnoreCase('<')){
				mips += relExp(E, 'slt')
			}
			
			if (E.op.equalsIgnoreCase('<=')){
				mips += relExp(E, 'sle')
			}
			
			if (E.op.equalsIgnoreCase('==')){
				mips += relExp(E, 'seq')
			}
			
			if (E.op.equalsIgnoreCase('!=')){
				mips += relExp(E, 'sne')
			}
			
			return mips
		}
		
		if (E instanceof LogicExp) {
			if (E.op.equalsIgnoreCase('&&')){
				mips += logicExp(E, 'and')
			}
			
			if (E.op.equalsIgnoreCase('||')){
				mips += logicExp(E, 'or')
			}
		}
		
		if (E instanceof PostfixOp) {
			val op = E.uo
			
			if (E.arg instanceof Var) {
			    val vName = (E.arg as Var).valor.name
				val id = getReference(vName)
				
				mips +=
				'''
				lw		$t9, «id»
				«push('t9')»
				«IF op == "++"»
				addiu	$t9, $t9, 1
				«ELSEIF op == "--"»
				addiu	$t9, $t9, -1
				«ENDIF»
				sw		$t9, «id»
				
				'''
			}
			
			return mips
		}
		
		if (E instanceof PrefixOp) {
			val op = E.uo
			
			if (E.arg instanceof Var) {
			    val vName = (E.arg as Var).valor.name
			    val id = getReference(vName)

				mips +=
				'''
				lw		$t9, «id»
				«IF op == "++"»
				addiu	$t9, $t9, 1
				«ELSEIF op == "--"»
				addiu	$t9, $t9, -1
				«ENDIF»
				sw		$t9, «id»
				«push('t9')»
				
				'''
			}
			
			return mips
		}
		
		if (E instanceof Parenteses) {
			return expression(E.exp)
		}
		
		if (E instanceof FuncCall) {
			val func 		= E.def as Var
			val funcName 	= if (func.valor.name == "main") func.valor.name else "_"+func.valor.name

			mips += 
			'''
			«var argNum = 0»
			«IF E.arg !== null»
				«FOR arg : E.arg.exp»
					«expression(arg)»
					«pop('t0')»
					move		$a«argNum++», $t0 
				«ENDFOR»
				
			«ENDIF»	
			«jumpLink(funcName)»
			«push('v0')»
			
			'''

			return mips
		}
		
		if (E instanceof ArrayAccess) {
			val arr 		= E.arr as Var
			val varname 	= arr.valor.name
			val decl 	= arr.valor as VarDecl
			val tipo 	= decl.tipo.tipo
			
			var id = ''''''
			var idx = ''''''
			if (E.index instanceof IntLit && locals.containsKey(varname) != true) {
				idx = '''+«(E.index as IntLit).^val * 4»'''
				id 	= getReference(varname) + idx
			} else {
				mips += 
				'''
				«expression(E.index)»
				«pop('t5')»
				
				«IF locals.containsKey(varname)»
					la		$t6, -8($fp)
					li		$t4, «locals.get(varname)»
					sll		$t4, $t4, 2
					sub		$t6, $t6, $t4
					sll		$t5, $t5, 2
					sub		$t5, $t6, $t5
				«ELSE»
					la		$t6, «getReference(varname)»
					sll		$t5, $t5, 2
					add		$t5, $t6, $t5
				«ENDIF»
				
				'''
				
				id  = '''0($t5)'''
			}
			
			val opCode	= if (tipo == 'string' && globals.containsKey(varname)) 'la' else 'lw'
			
			mips += evalExp(opCode, id)
			
			return mips
		}
		
		if (E instanceof Var) {
			val varname	= E.valor.name
			val decl 	= E.valor as VarDecl
			val tipo 	= decl.tipo.tipo
			
			var opCode	= if (tipo == 'string' && globals.containsKey(varname)) 'la' else 'lw'
			opCode 		= if(params.containsKey(varname)) 'move' else opCode
			val id 		= getReference(varname)
			
			mips += evalExp(opCode, id)
			
			return mips
		}
		
		if (E instanceof IntLit) {
			val valor = E.^val
			
			mips += evalExp('li', valor.toString)
			
			return mips
		}
		
		if (E instanceof TrueLit) {
			mips += evalExp('li', '1')
			
			return mips
		}
		
		if (E instanceof FalseLit) {
			mips += evalExp('li', '0')
			
			return mips
		}
		
		if (E instanceof StrLit) {
			val strLabel = 'S'+nextLabel
			
			mips += storeString(E, strLabel)
			
			return mips
		}
		
		//TODO
	    if (E instanceof FieldAccess) {
		}
		//TODO
		if (E instanceof PointerExp) {
		}
		
		return mips
	}
	
	def arithExp(ArithExp E, String opCode){
		var mips = 
		'''
		«expression(E.args.get(0))»
		«expression(E.args.get(1))»
		«pop('t1')»
		«pop('t0')»
		«opCode»		$t0, $t0, $t1
		«push('t0')»
		
	 	'''
	 	return mips
	}
	
	def logicExp(LogicExp E, String opCode){
		var mips = 
		'''
		«expression(E.args.get(0))»
		«expression(E.args.get(1))»
		«pop('t1')»
		«pop('t0')»
		«opCode»		$t0, $t0, $t1
		«push('t0')»
		
	 	'''
	 	return mips
	}
	
	def termExp(Term E, String opCode){
		var mips = 
		'''
		«expression(E.args.get(0))»
		«expression(E.args.get(1))»
		«pop('t1')»
		«pop('t0')»
		«opCode»		$t0, $t0, $t1
		«push('t0')»
		
	 	'''
	 	return mips
	}
	
	def relExp(RelExp E, String opCode) {
		var mips = 
		'''
		«expression(E.args.get(0))»
		«expression(E.args.get(1))»
		«pop('t1')»
		«pop('t0')»
		«opCode»		$t0, $t0, $t1
		«push('t0')»
		
	 	'''
	 	return mips
	}

		
//------------------------------------------------------------------------------------------
// AUX
//------------------------------------------------------------------------------------------
		
	def functionEntry(int paramSize)
	'''
		sw	 	$ra, 0($sp)
		addiu 	$sp, $sp, -4
		sw   	$fp, 0($sp)
		addiu	$sp, $sp, -4
		addiu 	$fp, $sp, «paramSize + 8»
		addiu 	$sp, $sp, -«this.localSize»
		
	'''
	
	def functionExit(int paramSize)
	'''
	«fName.pop»_return:
	  lw   $ra, -«paramSize»($fp)
	  move $t0, $fp
	  lw   $fp, -«paramSize + 4»($fp)
	  move $sp, $t0
	  jr   $ra
	'''
	
	def CharSequence jumpLink(String func)
	'''
		jal «func»
	'''
	
	def CharSequence store(Expression E) {
		val varexp 	= E as Var
		val varname	= varexp.valor.name
		var mips 	= ''''''
		
		if (locals.containsKey(varname)) {
			mips += 
			'''
			«pop('t7')»
			«indexed('sw', 't7', locals.get(varname)+8, 'fp')»
			
			'''
			
			return mips
		}
		
		if (globals.containsKey(varname)) {
			mips +=
			'''
			«pop('t9')»
			sw		$t9, _«globals.get(varname)»
			
			'''
			return mips
		}
		
		return mips
	}
	
	def storeArray(ArrayAccess A) {
		var mips 	= ''''''
		val varname	= (A.arr as Var).valor.name
		val arrIdx 	= (A.index as IntLit).^val * 4
		
		if (locals.containsKey(varname)) {
			mips += 
			'''
			«pop('t7')»
			«indexed('sw', 't7', locals.get(varname)+arrIdx+8, 'fp')»
			
			'''
			
			return mips
		}
		
		if (globals.containsKey(varname)) {
			mips +=
			'''
			«pop('t9')»
			sw		$t9, _«globals.get(varname)»+«arrIdx»
			
			'''
			return mips
		}
		
		return mips
	}
	
	def storeString(StrLit E, String strLabel) {
			var mips = 
			'''
			.data
			_«strLabel»: .asciiz "«E.^val»"
			.text
			«evalExp('la', '_'+strLabel)»
			''' 
			
			return mips
	}
	
	def CharSequence evalExp(String opCode, String value) {
			var mips =
			'''
			«opCode»		$t8, «value»
			«push('t8')»
			
			'''
			
			return mips
	}
	
	def CharSequence push(String reg)
	'''
		addiu	$sp, $sp, -4
		sw		$«reg», ($sp)
	'''
	
	def CharSequence pop(String reg)
	'''
		lw 		$«reg», ($sp)
		addiu	$sp, $sp, 4
	'''

	def CharSequence indexed(String opCode, String reg1, int offset, String reg2)
	'''
		«opCode»		$«reg1», -«offset»($«reg2»)
	'''

	def getReference(String varname) {
		if (params.containsKey(varname)) {
			return "$a"+params.get(varname)
		}
		
		if (locals.containsKey(varname)) {
			return "-"+(locals.get(varname)+8)+"($fp)" 
		}
		
		return '_'+globals.get(varname)
	}
	
	def getParamSize(EList<Declaration> decs) {
		var size = 0
		var argNum = 0
		
		for(d : decs) {
			val tipo 		= (d as VarDecl).tipo
			val paramName 	= (d as VarDecl).name
			var paramSize 	= 0
			
			if (tipo.exp !== null) {
				paramSize = (tipo.exp as IntLit).^val * 4
			} else {
				paramSize = 4
			}
			
			params.put(paramName, argNum)
			argNum++
			size += paramSize
		}
		
		return size
	}

	def nextLabel() {
		this.label++
		
		return 'L'+this.label
	}
	
	def orderStack(Stack<String> s) {
		var Stack<String> ordered = new Stack
		
		while(! s.empty()) {
			ordered.push(s.pop)
		}
		
		return ordered
	}
	
	def calculateLocals(Resource resource, Program p) {
		val declarations				= resource.allContents.filter(Declaration).toList
		val definitions 				= p.definition
		var List<Declaration> global	= new ArrayList
		var List<Declaration> local 	= new ArrayList
		var size 					= 0
		
		for(d : definitions) {
			if (d instanceof Declaration) {
				global.add(d)
			}
		}
		
		for(d : declarations) {
			if (global.indexOf(d) == -1) {
				local.add(d)
			}
		}
		
		for(l : local) {
			if (l instanceof VarDecl) {
				if (l.tipo.exp === null) {
					size += 4
				} else {
					val arrIdx 	= l.tipo.exp
					val arrSize	= (arrIdx as IntLit).^val
					
					size += arrSize*4;
				}
			}
		}
		
		this.localSize = size
	}
	
}
