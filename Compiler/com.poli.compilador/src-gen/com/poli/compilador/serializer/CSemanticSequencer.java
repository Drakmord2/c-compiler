/*
 * generated by Xtext 2.12.0
 */
package com.poli.compilador.serializer;

import com.google.inject.Inject;
import com.poli.compilador.c.Argument;
import com.poli.compilador.c.AritmExp;
import com.poli.compilador.c.Assignment;
import com.poli.compilador.c.CPackage;
import com.poli.compilador.c.Case;
import com.poli.compilador.c.CommandBlock;
import com.poli.compilador.c.Declaration;
import com.poli.compilador.c.Expression;
import com.poli.compilador.c.Factor;
import com.poli.compilador.c.FalseLit;
import com.poli.compilador.c.Function;
import com.poli.compilador.c.IdDef;
import com.poli.compilador.c.IntLit;
import com.poli.compilador.c.LogicExp;
import com.poli.compilador.c.PointerExp;
import com.poli.compilador.c.Program;
import com.poli.compilador.c.RelExp;
import com.poli.compilador.c.Struct;
import com.poli.compilador.c.Term;
import com.poli.compilador.c.TrueLit;
import com.poli.compilador.c.Type;
import com.poli.compilador.c.Variable;
import com.poli.compilador.c.arrayAccess;
import com.poli.compilador.c.breakCmd;
import com.poli.compilador.c.continueCmd;
import com.poli.compilador.c.doWhileCmd;
import com.poli.compilador.c.fieldAccess;
import com.poli.compilador.c.forCmd;
import com.poli.compilador.c.ifCmd;
import com.poli.compilador.c.lValue;
import com.poli.compilador.c.returnCmd;
import com.poli.compilador.c.switchCmd;
import com.poli.compilador.c.varCmd;
import com.poli.compilador.c.whileCmd;
import com.poli.compilador.services.CGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CPackage.ARGUMENT:
				sequence_Argument(context, (Argument) semanticObject); 
				return; 
			case CPackage.ARITM_EXP:
				sequence_ArithExp(context, (AritmExp) semanticObject); 
				return; 
			case CPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case CPackage.CASE:
				sequence_Case(context, (Case) semanticObject); 
				return; 
			case CPackage.COMMAND_BLOCK:
				sequence_CommandBlock(context, (CommandBlock) semanticObject); 
				return; 
			case CPackage.DECLARATION:
				sequence_Declaration(context, (Declaration) semanticObject); 
				return; 
			case CPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case CPackage.FACTOR:
				sequence_Factor(context, (Factor) semanticObject); 
				return; 
			case CPackage.FALSE_LIT:
				sequence_Literal(context, (FalseLit) semanticObject); 
				return; 
			case CPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case CPackage.ID_DEF:
				sequence_IdDef(context, (IdDef) semanticObject); 
				return; 
			case CPackage.INT_LIT:
				sequence_Literal(context, (IntLit) semanticObject); 
				return; 
			case CPackage.LOGIC_EXP:
				sequence_Expression(context, (LogicExp) semanticObject); 
				return; 
			case CPackage.POINTER_EXP:
				sequence_PointerExp(context, (PointerExp) semanticObject); 
				return; 
			case CPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case CPackage.REL_EXP:
				sequence_RelExp(context, (RelExp) semanticObject); 
				return; 
			case CPackage.STRUCT:
				sequence_Struct(context, (Struct) semanticObject); 
				return; 
			case CPackage.TERM:
				sequence_Term(context, (Term) semanticObject); 
				return; 
			case CPackage.TRUE_LIT:
				sequence_Literal(context, (TrueLit) semanticObject); 
				return; 
			case CPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case CPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case CPackage.ARRAY_ACCESS:
				sequence_AccessExp(context, (arrayAccess) semanticObject); 
				return; 
			case CPackage.BREAK_CMD:
				sequence_Command(context, (breakCmd) semanticObject); 
				return; 
			case CPackage.CONTINUE_CMD:
				sequence_Command(context, (continueCmd) semanticObject); 
				return; 
			case CPackage.DO_WHILE_CMD:
				sequence_Command(context, (doWhileCmd) semanticObject); 
				return; 
			case CPackage.FIELD_ACCESS:
				sequence_AccessExp(context, (fieldAccess) semanticObject); 
				return; 
			case CPackage.FOR_CMD:
				sequence_Command(context, (forCmd) semanticObject); 
				return; 
			case CPackage.IF_CMD:
				sequence_Command(context, (ifCmd) semanticObject); 
				return; 
			case CPackage.LVALUE:
				sequence_lValue(context, (lValue) semanticObject); 
				return; 
			case CPackage.RETURN_CMD:
				sequence_Command(context, (returnCmd) semanticObject); 
				return; 
			case CPackage.SWITCH_CMD:
				sequence_Command(context, (switchCmd) semanticObject); 
				return; 
			case CPackage.VAR_CMD:
				sequence_Command(context, (varCmd) semanticObject); 
				return; 
			case CPackage.WHILE_CMD:
				sequence_Command(context, (whileCmd) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AccessExp returns arrayAccess
	 *
	 * Constraint:
	 *     exp=Expression?
	 */
	protected void sequence_AccessExp(ISerializationContext context, arrayAccess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AccessExp returns fieldAccess
	 *
	 * Constraint:
	 *     field=ID
	 */
	protected void sequence_AccessExp(ISerializationContext context, fieldAccess semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPackage.Literals.FIELD_ACCESS__FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPackage.Literals.FIELD_ACCESS__FIELD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAccessExpAccess().getFieldIDTerminalRuleCall_1_2_0(), semanticObject.getField());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Argument returns Argument
	 *
	 * Constraint:
	 *     (exp+=Expression exp+=Expression*)
	 */
	protected void sequence_Argument(ISerializationContext context, Argument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelExp returns AritmExp
	 *     RelExp.RelExp_1_0 returns AritmExp
	 *     ArithExp returns AritmExp
	 *     ArithExp.AritmExp_1_0 returns AritmExp
	 *
	 * Constraint:
	 *     (args+=ArithExp_AritmExp_1_0 op=AO1 args+=Term)
	 */
	protected void sequence_ArithExp(ISerializationContext context, AritmExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     exp=Expression
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPackage.Literals.ASSIGNMENT__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPackage.Literals.ASSIGNMENT__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getExpExpressionParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Case returns Case
	 *
	 * Constraint:
	 *     (val=Atom commands+=Command*)
	 */
	protected void sequence_Case(ISerializationContext context, Case semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommandBlock returns CommandBlock
	 *
	 * Constraint:
	 *     commands+=Command*
	 */
	protected void sequence_CommandBlock(ISerializationContext context, CommandBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns breakCmd
	 *
	 * Constraint:
	 *     {breakCmd}
	 */
	protected void sequence_Command(ISerializationContext context, breakCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns continueCmd
	 *
	 * Constraint:
	 *     {continueCmd}
	 */
	protected void sequence_Command(ISerializationContext context, continueCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns doWhileCmd
	 *
	 * Constraint:
	 *     (commands=CommandBlock exp=Expression)
	 */
	protected void sequence_Command(ISerializationContext context, doWhileCmd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPackage.Literals.DO_WHILE_CMD__COMMANDS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPackage.Literals.DO_WHILE_CMD__COMMANDS));
			if (transientValues.isValueTransient(semanticObject, CPackage.Literals.DO_WHILE_CMD__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPackage.Literals.DO_WHILE_CMD__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCommandAccess().getCommandsCommandBlockParserRuleCall_5_2_0(), semanticObject.getCommands());
		feeder.accept(grammarAccess.getCommandAccess().getExpExpressionParserRuleCall_5_5_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns forCmd
	 *
	 * Constraint:
	 *     (
	 *         init+=lValue 
	 *         init+=Assignment 
	 *         exp=Expression 
	 *         inc+=Factor 
	 *         inc+=Assignment? 
	 *         commands=CommandBlock
	 *     )
	 */
	protected void sequence_Command(ISerializationContext context, forCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns ifCmd
	 *
	 * Constraint:
	 *     (exp=Expression trueCommands=CommandBlock falseCommands=CommandBlock?)
	 */
	protected void sequence_Command(ISerializationContext context, ifCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns returnCmd
	 *
	 * Constraint:
	 *     exp+=Expression?
	 */
	protected void sequence_Command(ISerializationContext context, returnCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns switchCmd
	 *
	 * Constraint:
	 *     (exp=Expression cases+=Case* commands+=Command*)
	 */
	protected void sequence_Command(ISerializationContext context, switchCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns varCmd
	 *
	 * Constraint:
	 *     (val+=Factor val+=Assignment?)
	 */
	protected void sequence_Command(ISerializationContext context, varCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns whileCmd
	 *
	 * Constraint:
	 *     (exp=Expression commands=CommandBlock)
	 */
	protected void sequence_Command(ISerializationContext context, whileCmd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPackage.Literals.WHILE_CMD__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPackage.Literals.WHILE_CMD__EXP));
			if (transientValues.isValueTransient(semanticObject, CPackage.Literals.WHILE_CMD__COMMANDS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPackage.Literals.WHILE_CMD__COMMANDS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCommandAccess().getExpExpressionParserRuleCall_1_3_0(), semanticObject.getExp());
		feeder.accept(grammarAccess.getCommandAccess().getCommandsCommandBlockParserRuleCall_1_5_0(), semanticObject.getCommands());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns Declaration
	 *     Declaration returns Declaration
	 *     Command returns Declaration
	 *
	 * Constraint:
	 *     ((tipo=Type name=ID val=Assignment?) | (str=[Struct|ID] name=ID))
	 */
	protected void sequence_Declaration(ISerializationContext context, Declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *     Expression.LogicExp_1_0 returns Expression
	 *     Atom returns Expression
	 *
	 * Constraint:
	 *     args+=RelExp
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LogicExp
	 *     Expression.LogicExp_1_0 returns LogicExp
	 *     Atom returns LogicExp
	 *
	 * Constraint:
	 *     (args+=Expression_LogicExp_1_0 op=LO args+=RelExp)
	 */
	protected void sequence_Expression(ISerializationContext context, LogicExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelExp returns Factor
	 *     RelExp.RelExp_1_0 returns Factor
	 *     ArithExp returns Factor
	 *     ArithExp.AritmExp_1_0 returns Factor
	 *     Term returns Factor
	 *     Term.Term_1_0 returns Factor
	 *     Factor returns Factor
	 *
	 * Constraint:
	 *     (uo+=UO? arg=Atom uo+=UO?)
	 */
	protected void sequence_Factor(ISerializationContext context, Factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns Function
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (tipo=Type name=ID (params+=IdDef params+=IdDef*)? commands+=Command*)
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IdDef returns IdDef
	 *
	 * Constraint:
	 *     (tipo=Type name=Variable)
	 */
	protected void sequence_IdDef(ISerializationContext context, IdDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPackage.Literals.ID_DEF__TIPO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPackage.Literals.ID_DEF__TIPO));
			if (transientValues.isValueTransient(semanticObject, CPackage.Literals.ID_DEF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPackage.Literals.ID_DEF__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIdDefAccess().getTipoTypeParserRuleCall_0_0(), semanticObject.getTipo());
		feeder.accept(grammarAccess.getIdDefAccess().getNameVariableParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Atom returns FalseLit
	 *     Literal returns FalseLit
	 *
	 * Constraint:
	 *     val=FALSE
	 */
	protected void sequence_Literal(ISerializationContext context, FalseLit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPackage.Literals.FALSE_LIT__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPackage.Literals.FALSE_LIT__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralAccess().getValFALSETerminalRuleCall_2_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Atom returns IntLit
	 *     Literal returns IntLit
	 *
	 * Constraint:
	 *     val=INT
	 */
	protected void sequence_Literal(ISerializationContext context, IntLit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPackage.Literals.INT_LIT__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPackage.Literals.INT_LIT__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralAccess().getValINTTerminalRuleCall_0_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Atom returns TrueLit
	 *     Literal returns TrueLit
	 *
	 * Constraint:
	 *     val=TRUE
	 */
	protected void sequence_Literal(ISerializationContext context, TrueLit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPackage.Literals.TRUE_LIT__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPackage.Literals.TRUE_LIT__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralAccess().getValTRUETerminalRuleCall_1_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns PointerExp
	 *     Atom returns PointerExp
	 *     lValue returns PointerExp
	 *     PointerExp returns PointerExp
	 *
	 * Constraint:
	 *     exp=Expression?
	 */
	protected void sequence_PointerExp(ISerializationContext context, PointerExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     definition+=Definition+
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelExp returns RelExp
	 *
	 * Constraint:
	 *     (args+=RelExp_RelExp_1_0 op=RO args+=ArithExp)
	 */
	protected void sequence_RelExp(ISerializationContext context, RelExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns Struct
	 *     Struct returns Struct
	 *
	 * Constraint:
	 *     (name=ID decl+=Declaration*)
	 */
	protected void sequence_Struct(ISerializationContext context, Struct semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelExp returns Term
	 *     RelExp.RelExp_1_0 returns Term
	 *     ArithExp returns Term
	 *     ArithExp.AritmExp_1_0 returns Term
	 *     Term returns Term
	 *     Term.Term_1_0 returns Term
	 *
	 * Constraint:
	 *     (args+=Term_Term_1_0 op=AO2 args+=Factor)
	 */
	protected void sequence_Term(ISerializationContext context, Term semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *
	 * Constraint:
	 *     (tipo=TYPELIT exp=Expression?)
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     {Variable}
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Atom returns lValue
	 *     lValue returns lValue
	 *
	 * Constraint:
	 *     (valor=[Definition|ID] (arg=Argument | acc=AccessExp)?)
	 */
	protected void sequence_lValue(ISerializationContext context, lValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
