/*
 * generated by Xtext 2.12.0
 */
package com.poli.compilador.serializer;

import com.google.inject.Inject;
import com.poli.compilador.c.AritmExp;
import com.poli.compilador.c.CPackage;
import com.poli.compilador.c.Command;
import com.poli.compilador.c.Declaration;
import com.poli.compilador.c.Definition;
import com.poli.compilador.c.Expression;
import com.poli.compilador.c.FalseLit;
import com.poli.compilador.c.Function;
import com.poli.compilador.c.IDVal;
import com.poli.compilador.c.IntLit;
import com.poli.compilador.c.LogicExp;
import com.poli.compilador.c.PointerExp;
import com.poli.compilador.c.Program;
import com.poli.compilador.c.RelExp;
import com.poli.compilador.c.Term;
import com.poli.compilador.c.TrueLit;
import com.poli.compilador.c.UnaryExp;
import com.poli.compilador.services.CGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CPackage.ARITM_EXP:
				sequence_ArithExp(context, (AritmExp) semanticObject); 
				return; 
			case CPackage.COMMAND:
				sequence_Command(context, (Command) semanticObject); 
				return; 
			case CPackage.DECLARATION:
				sequence_Declaration(context, (Declaration) semanticObject); 
				return; 
			case CPackage.DEFINITION:
				sequence_Definition(context, (Definition) semanticObject); 
				return; 
			case CPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case CPackage.FALSE_LIT:
				sequence_Literal(context, (FalseLit) semanticObject); 
				return; 
			case CPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case CPackage.ID_VAL:
				sequence_lValue(context, (IDVal) semanticObject); 
				return; 
			case CPackage.INT_LIT:
				sequence_Literal(context, (IntLit) semanticObject); 
				return; 
			case CPackage.LOGIC_EXP:
				sequence_Expression(context, (LogicExp) semanticObject); 
				return; 
			case CPackage.POINTER_EXP:
				sequence_PointerExp(context, (PointerExp) semanticObject); 
				return; 
			case CPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case CPackage.REL_EXP:
				sequence_RelExp(context, (RelExp) semanticObject); 
				return; 
			case CPackage.TERM:
				sequence_Term(context, (Term) semanticObject); 
				return; 
			case CPackage.TRUE_LIT:
				sequence_Literal(context, (TrueLit) semanticObject); 
				return; 
			case CPackage.UNARY_EXP:
				sequence_Factor(context, (UnaryExp) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     RelExp returns AritmExp
	 *     RelExp.RelExp_1_0 returns AritmExp
	 *     ArithExp returns AritmExp
	 *     ArithExp.AritmExp_1_0 returns AritmExp
	 *
	 * Constraint:
	 *     (args+=ArithExp_AritmExp_1_0 val=AO1 args+=Term)
	 */
	protected void sequence_ArithExp(ISerializationContext context, AritmExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Command
	 *
	 * Constraint:
	 *     ((exp+=Expression commands+=Command* commands+=Command*) | exp+=Expression)?
	 */
	protected void sequence_Command(ISerializationContext context, Command semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns Declaration
	 *     Declaration returns Declaration
	 *
	 * Constraint:
	 *     (tipo=Type name+=ID* asg=Assignment)
	 */
	protected void sequence_Declaration(ISerializationContext context, Declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns Definition
	 *
	 * Constraint:
	 *     val+=Function
	 */
	protected void sequence_Definition(ISerializationContext context, Definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *     Expression.LogicExp_1_0 returns Expression
	 *     RelExp returns Expression
	 *     RelExp.RelExp_1_0 returns Expression
	 *     ArithExp returns Expression
	 *     ArithExp.AritmExp_1_0 returns Expression
	 *     Term returns Expression
	 *     Term.Term_1_0 returns Expression
	 *     Factor returns Expression
	 *     Atom returns Expression
	 *
	 * Constraint:
	 *     args+=RelExp
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LogicExp
	 *     Expression.LogicExp_1_0 returns LogicExp
	 *     RelExp returns LogicExp
	 *     RelExp.RelExp_1_0 returns LogicExp
	 *     ArithExp returns LogicExp
	 *     ArithExp.AritmExp_1_0 returns LogicExp
	 *     Term returns LogicExp
	 *     Term.Term_1_0 returns LogicExp
	 *     Factor returns LogicExp
	 *     Atom returns LogicExp
	 *
	 * Constraint:
	 *     (args+=Expression_LogicExp_1_0 val=LO args+=RelExp)
	 */
	protected void sequence_Expression(ISerializationContext context, LogicExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelExp returns UnaryExp
	 *     RelExp.RelExp_1_0 returns UnaryExp
	 *     ArithExp returns UnaryExp
	 *     ArithExp.AritmExp_1_0 returns UnaryExp
	 *     Term returns UnaryExp
	 *     Term.Term_1_0 returns UnaryExp
	 *     Factor returns UnaryExp
	 *
	 * Constraint:
	 *     (val=UO args+=Atom)
	 */
	protected void sequence_Factor(ISerializationContext context, UnaryExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (tipo=Type name=ID params+=Parameter? commands+=Command*)
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelExp returns FalseLit
	 *     RelExp.RelExp_1_0 returns FalseLit
	 *     ArithExp returns FalseLit
	 *     ArithExp.AritmExp_1_0 returns FalseLit
	 *     Term returns FalseLit
	 *     Term.Term_1_0 returns FalseLit
	 *     Factor returns FalseLit
	 *     Atom returns FalseLit
	 *     Literal returns FalseLit
	 *
	 * Constraint:
	 *     val=FALSE
	 */
	protected void sequence_Literal(ISerializationContext context, FalseLit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPackage.Literals.REL_EXP__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPackage.Literals.REL_EXP__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralAccess().getValFALSETerminalRuleCall_2_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RelExp returns IntLit
	 *     RelExp.RelExp_1_0 returns IntLit
	 *     ArithExp returns IntLit
	 *     ArithExp.AritmExp_1_0 returns IntLit
	 *     Term returns IntLit
	 *     Term.Term_1_0 returns IntLit
	 *     Factor returns IntLit
	 *     Atom returns IntLit
	 *     Literal returns IntLit
	 *
	 * Constraint:
	 *     valor=INT
	 */
	protected void sequence_Literal(ISerializationContext context, IntLit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPackage.Literals.INT_LIT__VALOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPackage.Literals.INT_LIT__VALOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralAccess().getValorINTTerminalRuleCall_0_1_0(), semanticObject.getValor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RelExp returns TrueLit
	 *     RelExp.RelExp_1_0 returns TrueLit
	 *     ArithExp returns TrueLit
	 *     ArithExp.AritmExp_1_0 returns TrueLit
	 *     Term returns TrueLit
	 *     Term.Term_1_0 returns TrueLit
	 *     Factor returns TrueLit
	 *     Atom returns TrueLit
	 *     Literal returns TrueLit
	 *
	 * Constraint:
	 *     val=TRUE
	 */
	protected void sequence_Literal(ISerializationContext context, TrueLit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPackage.Literals.REL_EXP__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPackage.Literals.REL_EXP__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralAccess().getValTRUETerminalRuleCall_1_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RelExp returns PointerExp
	 *     RelExp.RelExp_1_0 returns PointerExp
	 *     ArithExp returns PointerExp
	 *     ArithExp.AritmExp_1_0 returns PointerExp
	 *     Term returns PointerExp
	 *     Term.Term_1_0 returns PointerExp
	 *     Factor returns PointerExp
	 *     Atom returns PointerExp
	 *     lValue returns PointerExp
	 *     PointerExp returns PointerExp
	 *
	 * Constraint:
	 *     ptr=Atom
	 */
	protected void sequence_PointerExp(ISerializationContext context, PointerExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPackage.Literals.POINTER_EXP__PTR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPackage.Literals.POINTER_EXP__PTR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointerExpAccess().getPtrAtomParserRuleCall_1_0(), semanticObject.getPtr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     definition+=Definition+
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelExp returns RelExp
	 *
	 * Constraint:
	 *     (args+=RelExp_RelExp_1_0 val=RO args+=ArithExp)
	 */
	protected void sequence_RelExp(ISerializationContext context, RelExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelExp returns Term
	 *     RelExp.RelExp_1_0 returns Term
	 *     ArithExp returns Term
	 *     ArithExp.AritmExp_1_0 returns Term
	 *     Term returns Term
	 *     Term.Term_1_0 returns Term
	 *
	 * Constraint:
	 *     (args+=Term_Term_1_0 val=AO2 args+=Factor)
	 */
	protected void sequence_Term(ISerializationContext context, Term semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelExp returns IDVal
	 *     RelExp.RelExp_1_0 returns IDVal
	 *     ArithExp returns IDVal
	 *     ArithExp.AritmExp_1_0 returns IDVal
	 *     Term returns IDVal
	 *     Term.Term_1_0 returns IDVal
	 *     Factor returns IDVal
	 *     Atom returns IDVal
	 *     lValue returns IDVal
	 *
	 * Constraint:
	 *     val=ID
	 */
	protected void sequence_lValue(ISerializationContext context, IDVal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPackage.Literals.REL_EXP__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPackage.Literals.REL_EXP__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLValueAccess().getValIDTerminalRuleCall_0_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
}
