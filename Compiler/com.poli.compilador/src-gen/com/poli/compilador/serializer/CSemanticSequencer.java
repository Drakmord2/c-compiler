/*
 * generated by Xtext 2.12.0
 */
package com.poli.compilador.serializer;

import com.google.inject.Inject;
import com.poli.compilador.c.Argument;
import com.poli.compilador.c.AritmExp;
import com.poli.compilador.c.Assignment;
import com.poli.compilador.c.CPackage;
import com.poli.compilador.c.Case;
import com.poli.compilador.c.Declaration;
import com.poli.compilador.c.Expression;
import com.poli.compilador.c.FalseLit;
import com.poli.compilador.c.Function;
import com.poli.compilador.c.IdDef;
import com.poli.compilador.c.IntLit;
import com.poli.compilador.c.LogicExp;
import com.poli.compilador.c.PointerExp;
import com.poli.compilador.c.Program;
import com.poli.compilador.c.RelExp;
import com.poli.compilador.c.Struct;
import com.poli.compilador.c.Term;
import com.poli.compilador.c.TrueLit;
import com.poli.compilador.c.Type;
import com.poli.compilador.c.UnaryExp;
import com.poli.compilador.c.Variable;
import com.poli.compilador.c.arrayAccess;
import com.poli.compilador.c.breakCmd;
import com.poli.compilador.c.continueCmd;
import com.poli.compilador.c.declCmd;
import com.poli.compilador.c.doWhileCmd;
import com.poli.compilador.c.fieldAccess;
import com.poli.compilador.c.forCmd;
import com.poli.compilador.c.ifCmd;
import com.poli.compilador.c.lValue;
import com.poli.compilador.c.returnCmd;
import com.poli.compilador.c.switchCmd;
import com.poli.compilador.c.varCmd;
import com.poli.compilador.c.whileCmd;
import com.poli.compilador.services.CGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CPackage.ARGUMENT:
				sequence_Argument(context, (Argument) semanticObject); 
				return; 
			case CPackage.ARITM_EXP:
				sequence_ArithExp(context, (AritmExp) semanticObject); 
				return; 
			case CPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case CPackage.CASE:
				sequence_Case(context, (Case) semanticObject); 
				return; 
			case CPackage.DECLARATION:
				sequence_Declaration(context, (Declaration) semanticObject); 
				return; 
			case CPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case CPackage.FALSE_LIT:
				sequence_Literal(context, (FalseLit) semanticObject); 
				return; 
			case CPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case CPackage.ID_DEF:
				if (rule == grammarAccess.getDefinitionRule()) {
					sequence_Definition_IdDef(context, (IdDef) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIdDefRule()) {
					sequence_IdDef(context, (IdDef) semanticObject); 
					return; 
				}
				else break;
			case CPackage.INT_LIT:
				sequence_Literal(context, (IntLit) semanticObject); 
				return; 
			case CPackage.LOGIC_EXP:
				sequence_Expression(context, (LogicExp) semanticObject); 
				return; 
			case CPackage.PARAMETER:
				sequence_Parameter(context, (com.poli.compilador.c.Parameter) semanticObject); 
				return; 
			case CPackage.POINTER_EXP:
				sequence_PointerExp(context, (PointerExp) semanticObject); 
				return; 
			case CPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case CPackage.REL_EXP:
				sequence_RelExp(context, (RelExp) semanticObject); 
				return; 
			case CPackage.STRUCT:
				sequence_Struct(context, (Struct) semanticObject); 
				return; 
			case CPackage.TERM:
				sequence_Term(context, (Term) semanticObject); 
				return; 
			case CPackage.TRUE_LIT:
				sequence_Literal(context, (TrueLit) semanticObject); 
				return; 
			case CPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case CPackage.UNARY_EXP:
				sequence_Factor(context, (UnaryExp) semanticObject); 
				return; 
			case CPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case CPackage.ARRAY_ACCESS:
				sequence_AccessExp(context, (arrayAccess) semanticObject); 
				return; 
			case CPackage.BREAK_CMD:
				sequence_Command(context, (breakCmd) semanticObject); 
				return; 
			case CPackage.CONTINUE_CMD:
				sequence_Command(context, (continueCmd) semanticObject); 
				return; 
			case CPackage.DECL_CMD:
				sequence_Command(context, (declCmd) semanticObject); 
				return; 
			case CPackage.DO_WHILE_CMD:
				sequence_Command(context, (doWhileCmd) semanticObject); 
				return; 
			case CPackage.FIELD_ACCESS:
				sequence_AccessExp(context, (fieldAccess) semanticObject); 
				return; 
			case CPackage.FOR_CMD:
				sequence_Command(context, (forCmd) semanticObject); 
				return; 
			case CPackage.IF_CMD:
				sequence_Command(context, (ifCmd) semanticObject); 
				return; 
			case CPackage.LVALUE:
				sequence_lValue(context, (lValue) semanticObject); 
				return; 
			case CPackage.RETURN_CMD:
				sequence_Command(context, (returnCmd) semanticObject); 
				return; 
			case CPackage.SWITCH_CMD:
				sequence_Command(context, (switchCmd) semanticObject); 
				return; 
			case CPackage.VAR_CMD:
				sequence_Command(context, (varCmd) semanticObject); 
				return; 
			case CPackage.WHILE_CMD:
				sequence_Command(context, (whileCmd) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AccessExp returns arrayAccess
	 *
	 * Constraint:
	 *     exp+=Expression?
	 */
	protected void sequence_AccessExp(ISerializationContext context, arrayAccess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AccessExp returns fieldAccess
	 *
	 * Constraint:
	 *     field=ID
	 */
	protected void sequence_AccessExp(ISerializationContext context, fieldAccess semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPackage.Literals.FIELD_ACCESS__FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPackage.Literals.FIELD_ACCESS__FIELD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAccessExpAccess().getFieldIDTerminalRuleCall_1_2_0(), semanticObject.getField());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Argument returns Argument
	 *
	 * Constraint:
	 *     (exp+=Expression exp+=Expression*)
	 */
	protected void sequence_Argument(ISerializationContext context, Argument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelExp returns AritmExp
	 *     RelExp.RelExp_1_0 returns AritmExp
	 *     ArithExp returns AritmExp
	 *     ArithExp.AritmExp_1_0 returns AritmExp
	 *
	 * Constraint:
	 *     (args+=ArithExp_AritmExp_1_0 val=AO1 args+=Term)
	 */
	protected void sequence_ArithExp(ISerializationContext context, AritmExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     exp=Expression
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPackage.Literals.ASSIGNMENT__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPackage.Literals.ASSIGNMENT__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getExpExpressionParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Case returns Case
	 *
	 * Constraint:
	 *     (val+=Atom commands+=Command*)
	 */
	protected void sequence_Case(ISerializationContext context, Case semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns breakCmd
	 *
	 * Constraint:
	 *     {breakCmd}
	 */
	protected void sequence_Command(ISerializationContext context, breakCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns continueCmd
	 *
	 * Constraint:
	 *     {continueCmd}
	 */
	protected void sequence_Command(ISerializationContext context, continueCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns declCmd
	 *
	 * Constraint:
	 *     (def+=IdDef decl+=Declaration)
	 */
	protected void sequence_Command(ISerializationContext context, declCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns doWhileCmd
	 *
	 * Constraint:
	 *     (commands+=Command* exp+=Expression)
	 */
	protected void sequence_Command(ISerializationContext context, doWhileCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns forCmd
	 *
	 * Constraint:
	 *     (
	 *         val+=lValue 
	 *         val+=Assignment 
	 *         exp+=Expression 
	 *         val+=lValue 
	 *         val+=Assignment 
	 *         commands+=Command*
	 *     )
	 */
	protected void sequence_Command(ISerializationContext context, forCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns ifCmd
	 *
	 * Constraint:
	 *     (exp+=Expression commands+=Command* commands+=Command*)
	 */
	protected void sequence_Command(ISerializationContext context, ifCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns returnCmd
	 *
	 * Constraint:
	 *     exp+=Expression?
	 */
	protected void sequence_Command(ISerializationContext context, returnCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns switchCmd
	 *
	 * Constraint:
	 *     (exp+=Expression cases+=Case* commands+=Command*)
	 */
	protected void sequence_Command(ISerializationContext context, switchCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns varCmd
	 *
	 * Constraint:
	 *     (val+=lValue val+=Assignment?)?
	 */
	protected void sequence_Command(ISerializationContext context, varCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns whileCmd
	 *
	 * Constraint:
	 *     (exp+=Expression commands+=Command*)
	 */
	protected void sequence_Command(ISerializationContext context, whileCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Declaration
	 *
	 * Constraint:
	 *     (name+=Variable* val+=Assignment?)
	 */
	protected void sequence_Declaration(ISerializationContext context, Declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns IdDef
	 *
	 * Constraint:
	 *     (tipo=Type name+=Variable (val=Function | val=Declaration))
	 */
	protected void sequence_Definition_IdDef(ISerializationContext context, IdDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *     Expression.LogicExp_1_0 returns Expression
	 *     RelExp returns Expression
	 *     RelExp.RelExp_1_0 returns Expression
	 *     ArithExp returns Expression
	 *     ArithExp.AritmExp_1_0 returns Expression
	 *     Term returns Expression
	 *     Term.Term_1_0 returns Expression
	 *     Factor returns Expression
	 *     Atom returns Expression
	 *
	 * Constraint:
	 *     args+=RelExp
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LogicExp
	 *     Expression.LogicExp_1_0 returns LogicExp
	 *     RelExp returns LogicExp
	 *     RelExp.RelExp_1_0 returns LogicExp
	 *     ArithExp returns LogicExp
	 *     ArithExp.AritmExp_1_0 returns LogicExp
	 *     Term returns LogicExp
	 *     Term.Term_1_0 returns LogicExp
	 *     Factor returns LogicExp
	 *     Atom returns LogicExp
	 *
	 * Constraint:
	 *     (args+=Expression_LogicExp_1_0 val=LO args+=RelExp)
	 */
	protected void sequence_Expression(ISerializationContext context, LogicExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelExp returns UnaryExp
	 *     RelExp.RelExp_1_0 returns UnaryExp
	 *     ArithExp returns UnaryExp
	 *     ArithExp.AritmExp_1_0 returns UnaryExp
	 *     Term returns UnaryExp
	 *     Term.Term_1_0 returns UnaryExp
	 *     Factor returns UnaryExp
	 *
	 * Constraint:
	 *     (val=UO args+=Atom)
	 */
	protected void sequence_Factor(ISerializationContext context, UnaryExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (params+=Parameter? commands+=Command*)
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IdDef returns IdDef
	 *
	 * Constraint:
	 *     (tipo=Type name+=Variable)
	 */
	protected void sequence_IdDef(ISerializationContext context, IdDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelExp returns FalseLit
	 *     RelExp.RelExp_1_0 returns FalseLit
	 *     ArithExp returns FalseLit
	 *     ArithExp.AritmExp_1_0 returns FalseLit
	 *     Term returns FalseLit
	 *     Term.Term_1_0 returns FalseLit
	 *     Factor returns FalseLit
	 *     Atom returns FalseLit
	 *     Literal returns FalseLit
	 *
	 * Constraint:
	 *     val=FALSE
	 */
	protected void sequence_Literal(ISerializationContext context, FalseLit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPackage.Literals.REL_EXP__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPackage.Literals.REL_EXP__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralAccess().getValFALSETerminalRuleCall_2_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RelExp returns IntLit
	 *     RelExp.RelExp_1_0 returns IntLit
	 *     ArithExp returns IntLit
	 *     ArithExp.AritmExp_1_0 returns IntLit
	 *     Term returns IntLit
	 *     Term.Term_1_0 returns IntLit
	 *     Factor returns IntLit
	 *     Atom returns IntLit
	 *     Literal returns IntLit
	 *
	 * Constraint:
	 *     valor=INT
	 */
	protected void sequence_Literal(ISerializationContext context, IntLit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPackage.Literals.INT_LIT__VALOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPackage.Literals.INT_LIT__VALOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralAccess().getValorINTTerminalRuleCall_0_1_0(), semanticObject.getValor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RelExp returns TrueLit
	 *     RelExp.RelExp_1_0 returns TrueLit
	 *     ArithExp returns TrueLit
	 *     ArithExp.AritmExp_1_0 returns TrueLit
	 *     Term returns TrueLit
	 *     Term.Term_1_0 returns TrueLit
	 *     Factor returns TrueLit
	 *     Atom returns TrueLit
	 *     Literal returns TrueLit
	 *
	 * Constraint:
	 *     val=TRUE
	 */
	protected void sequence_Literal(ISerializationContext context, TrueLit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPackage.Literals.REL_EXP__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPackage.Literals.REL_EXP__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralAccess().getValTRUETerminalRuleCall_1_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (def+=IdDef def+=IdDef*)
	 */
	protected void sequence_Parameter(ISerializationContext context, com.poli.compilador.c.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns PointerExp
	 *     RelExp returns PointerExp
	 *     RelExp.RelExp_1_0 returns PointerExp
	 *     ArithExp returns PointerExp
	 *     ArithExp.AritmExp_1_0 returns PointerExp
	 *     Term returns PointerExp
	 *     Term.Term_1_0 returns PointerExp
	 *     Factor returns PointerExp
	 *     Atom returns PointerExp
	 *     lValue returns PointerExp
	 *     PointerExp returns PointerExp
	 *
	 * Constraint:
	 *     exp+=Expression?
	 */
	protected void sequence_PointerExp(ISerializationContext context, PointerExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     definition+=Definition+
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelExp returns RelExp
	 *
	 * Constraint:
	 *     (args+=RelExp_RelExp_1_0 val=RO args+=ArithExp)
	 */
	protected void sequence_RelExp(ISerializationContext context, RelExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns Struct
	 *     Struct returns Struct
	 *
	 * Constraint:
	 *     (name+=Variable def+=IdDef decl+=Declaration)
	 */
	protected void sequence_Struct(ISerializationContext context, Struct semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelExp returns Term
	 *     RelExp.RelExp_1_0 returns Term
	 *     ArithExp returns Term
	 *     ArithExp.AritmExp_1_0 returns Term
	 *     Term returns Term
	 *     Term.Term_1_0 returns Term
	 *
	 * Constraint:
	 *     (args+=Term_Term_1_0 val=AO2 args+=Factor)
	 */
	protected void sequence_Term(ISerializationContext context, Term semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *
	 * Constraint:
	 *     (tipo+=TYPELIT exp+=Expression?)
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     {Variable}
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelExp returns lValue
	 *     RelExp.RelExp_1_0 returns lValue
	 *     ArithExp returns lValue
	 *     ArithExp.AritmExp_1_0 returns lValue
	 *     Term returns lValue
	 *     Term.Term_1_0 returns lValue
	 *     Factor returns lValue
	 *     Atom returns lValue
	 *     lValue returns lValue
	 *
	 * Constraint:
	 *     (val=ID (args+=Argument | acc=AccessExp)?)
	 */
	protected void sequence_lValue(ISerializationContext context, lValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
