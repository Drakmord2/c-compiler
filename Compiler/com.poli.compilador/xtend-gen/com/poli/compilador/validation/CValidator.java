/**
 * generated by Xtext 2.12.0
 */
package com.poli.compilador.validation;

import com.google.common.base.Objects;
import com.poli.compilador.c.ArrayAccess;
import com.poli.compilador.c.CPackage;
import com.poli.compilador.c.Declaration;
import com.poli.compilador.c.Definition;
import com.poli.compilador.c.DoWhileCmd;
import com.poli.compilador.c.Expression;
import com.poli.compilador.c.FieldAccess;
import com.poli.compilador.c.ForCmd;
import com.poli.compilador.c.IfCmd;
import com.poli.compilador.c.IntLit;
import com.poli.compilador.c.StrDecl;
import com.poli.compilador.c.Struct;
import com.poli.compilador.c.SwitchCmd;
import com.poli.compilador.c.Type;
import com.poli.compilador.c.Var;
import com.poli.compilador.c.VarDecl;
import com.poli.compilador.c.WhileCmd;
import com.poli.compilador.validation.AbstractCValidator;
import com.poli.compilador.validation.Validator;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class CValidator extends AbstractCValidator {
  @Check
  public void checkIf(final IfCmd c) {
    final Validator.Tipo tipo = Validator.tipode(c.getExp(), null);
    boolean _notEquals = (!Objects.equal(tipo, Validator.Tipo.BOOL));
    if (_notEquals) {
      this.error((("Condition must be a Bool. " + tipo) + " given."), c, CPackage.Literals.IF_CMD__EXP);
    }
  }
  
  @Check
  public void checkWhile(final WhileCmd c) {
    final Validator.Tipo tipo = Validator.tipode(c.getExp(), null);
    boolean _notEquals = (!Objects.equal(tipo, Validator.Tipo.BOOL));
    if (_notEquals) {
      this.error((("Condition must be a Bool. " + tipo) + " given."), c, CPackage.Literals.WHILE_CMD__EXP);
    }
  }
  
  @Check
  public void checkDoWhile(final DoWhileCmd c) {
    final Validator.Tipo tipo = Validator.tipode(c.getExp(), null);
    boolean _notEquals = (!Objects.equal(tipo, Validator.Tipo.BOOL));
    if (_notEquals) {
      this.error((("Condition must be a Bool. " + tipo) + " given."), c, CPackage.Literals.DO_WHILE_CMD__EXP);
    }
  }
  
  @Check
  public void checkSwitch(final SwitchCmd c) {
    final Validator.Tipo tipo = Validator.tipode(c.getExp(), null);
    boolean _notEquals = (!Objects.equal(tipo, Validator.Tipo.BOOL));
    if (_notEquals) {
      this.error((("Condition must be a Bool. " + tipo) + " given."), c, CPackage.Literals.SWITCH_CMD__EXP);
    }
  }
  
  @Check
  public void checkFor(final ForCmd c) {
    final Validator.Tipo tipo = Validator.tipode(c.getExp(), null);
    boolean _notEquals = (!Objects.equal(tipo, Validator.Tipo.BOOL));
    if (_notEquals) {
      this.error((("Condition must be a Bool. " + tipo) + " given."), c, CPackage.Literals.FOR_CMD__EXP);
    }
  }
  
  @Check
  public void checkAccess(final Expression v) {
    if ((v instanceof FieldAccess)) {
      Expression _obj = ((FieldAccess)v).getObj();
      final Var lvalue = ((Var) _obj);
      Definition _valor = lvalue.getValor();
      boolean _notEquals = ((_valor instanceof StrDecl) != true);
      if (_notEquals) {
        this.error("Illegal access. Not a Struct.", v, CPackage.Literals.FIELD_ACCESS__OBJ);
        return;
      }
      Definition _valor_1 = lvalue.getValor();
      final StrDecl strDecl = ((StrDecl) _valor_1);
      final Struct struct = strDecl.getStr();
      final EList<Declaration> decls = struct.getDecl();
      final String campo = ((FieldAccess)v).getField();
      for (final Declaration d : decls) {
        String _name = d.getName();
        boolean _equals = Objects.equal(_name, campo);
        if (_equals) {
          return;
        }
      }
      this.error("Struct field not defined.", v, CPackage.Literals.FIELD_ACCESS__FIELD);
    }
    if ((v instanceof ArrayAccess)) {
      Expression _arr = ((ArrayAccess)v).getArr();
      final Var lvalue_1 = ((Var) _arr);
      Definition _valor_2 = lvalue_1.getValor();
      boolean _notEquals_1 = ((_valor_2 instanceof Declaration) != true);
      if (_notEquals_1) {
        return;
      }
      Definition _valor_3 = lvalue_1.getValor();
      final Declaration decl = ((Declaration) _valor_3);
      if (((decl instanceof VarDecl) != true)) {
        this.error("Illegal access. Not a variable.", v, CPackage.Literals.ARRAY_ACCESS__ARR);
        return;
      }
      final Type tipo = ((VarDecl) decl).getTipo();
      Expression _exp = tipo.getExp();
      boolean _tripleEquals = (_exp == null);
      if (_tripleEquals) {
        this.error("Illegal access. Not an Array.", v, CPackage.Literals.ARRAY_ACCESS__INDEX);
        return;
      }
      final Expression index = ((ArrayAccess)v).getIndex();
      Validator.Tipo _tipode = Validator.tipode(index, null);
      boolean _notEquals_2 = (!Objects.equal(_tipode, Validator.Tipo.INT));
      if (_notEquals_2) {
        this.error("Illegal access. Non integer index.", v, CPackage.Literals.ARRAY_ACCESS__INDEX);
        return;
      }
      if ((index instanceof Var)) {
        return;
      }
      if (((((IntLit) tipo.getExp()).getVal() < (((IntLit) index).getVal() + 1)) || (((IntLit) index).getVal() < 0))) {
        this.error("Array out of bounds.", v, CPackage.Literals.ARRAY_ACCESS__INDEX);
        return;
      }
    }
  }
}
