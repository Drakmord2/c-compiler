/**
 * generated by Xtext 2.12.0
 */
package com.poli.compilador.validation;

import com.google.common.base.Objects;
import com.poli.compilador.c.CPackage;
import com.poli.compilador.c.Declaration;
import com.poli.compilador.c.Definition;
import com.poli.compilador.c.Expression;
import com.poli.compilador.c.FieldAccess;
import com.poli.compilador.c.StrDecl;
import com.poli.compilador.c.Struct;
import com.poli.compilador.c.Var;
import com.poli.compilador.c.doWhileCmd;
import com.poli.compilador.c.forCmd;
import com.poli.compilador.c.ifCmd;
import com.poli.compilador.c.switchCmd;
import com.poli.compilador.c.whileCmd;
import com.poli.compilador.validation.AbstractCValidator;
import com.poli.compilador.validation.Validator;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class CValidator extends AbstractCValidator {
  @Check
  public void checkIf(final ifCmd c) {
    final Validator.Tipo tipo = Validator.tipode(c.getExp(), null);
    boolean _notEquals = (!Objects.equal(tipo, Validator.Tipo.BOOL));
    if (_notEquals) {
      this.error((("Condition must be a Bool. " + tipo) + " given."), c, CPackage.Literals.IF_CMD__EXP);
    }
  }
  
  @Check
  public void checkWhile(final whileCmd c) {
    final Validator.Tipo tipo = Validator.tipode(c.getExp(), null);
    boolean _notEquals = (!Objects.equal(tipo, Validator.Tipo.BOOL));
    if (_notEquals) {
      this.error((("Condition must be a Bool. " + tipo) + " given."), c, CPackage.Literals.WHILE_CMD__EXP);
    }
  }
  
  @Check
  public void checkDoWhile(final doWhileCmd c) {
    final Validator.Tipo tipo = Validator.tipode(c.getExp(), null);
    boolean _notEquals = (!Objects.equal(tipo, Validator.Tipo.BOOL));
    if (_notEquals) {
      this.error((("Condition must be a Bool. " + tipo) + " given."), c, CPackage.Literals.DO_WHILE_CMD__EXP);
    }
  }
  
  @Check
  public void checkSwitch(final switchCmd c) {
    final Validator.Tipo tipo = Validator.tipode(c.getExp(), null);
    boolean _notEquals = (!Objects.equal(tipo, Validator.Tipo.BOOL));
    if (_notEquals) {
      this.error((("Condition must be a Bool. " + tipo) + " given."), c, CPackage.Literals.SWITCH_CMD__EXP);
    }
  }
  
  @Check
  public void checkFor(final forCmd c) {
    final Validator.Tipo tipo = Validator.tipode(c.getExp(), null);
    boolean _notEquals = (!Objects.equal(tipo, Validator.Tipo.BOOL));
    if (_notEquals) {
      this.error((("Condition must be a Bool. " + tipo) + " given."), c, CPackage.Literals.FOR_CMD__EXP);
    }
  }
  
  @Check
  public void checkAccess(final Expression v) {
    if ((v instanceof FieldAccess)) {
      Expression _obj = ((FieldAccess)v).getObj();
      final Var lvalue = ((Var) _obj);
      Definition _valor = lvalue.getValor();
      boolean _notEquals = ((_valor instanceof StrDecl) != true);
      if (_notEquals) {
        this.error("Illegal access. Not a struct.", v, CPackage.Literals.FIELD_ACCESS__OBJ);
        return;
      }
      Definition _valor_1 = lvalue.getValor();
      final StrDecl strDecl = ((StrDecl) _valor_1);
      final Struct struct = strDecl.getStr();
      final EList<Declaration> decls = struct.getDecl();
      final String campo = ((FieldAccess)v).getField();
      for (final Declaration d : decls) {
        String _name = d.getName();
        boolean _equals = Objects.equal(_name, campo);
        if (_equals) {
          return;
        }
      }
      this.error("Struct field not defined.", v, CPackage.Literals.FIELD_ACCESS__FIELD);
    }
  }
}
