/**
 * generated by Xtext 2.12.0
 */
package com.poli.compilador.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterators;
import com.poli.compilador.c.ArrayAccess;
import com.poli.compilador.c.Assignment;
import com.poli.compilador.c.CPackage;
import com.poli.compilador.c.Case;
import com.poli.compilador.c.Command;
import com.poli.compilador.c.Declaration;
import com.poli.compilador.c.Definition;
import com.poli.compilador.c.DoWhileCmd;
import com.poli.compilador.c.Expression;
import com.poli.compilador.c.FieldAccess;
import com.poli.compilador.c.ForCmd;
import com.poli.compilador.c.FuncCall;
import com.poli.compilador.c.Function;
import com.poli.compilador.c.IfCmd;
import com.poli.compilador.c.IntLit;
import com.poli.compilador.c.Literal;
import com.poli.compilador.c.ReturnCmd;
import com.poli.compilador.c.StrDecl;
import com.poli.compilador.c.Struct;
import com.poli.compilador.c.SwitchCmd;
import com.poli.compilador.c.Type;
import com.poli.compilador.c.Var;
import com.poli.compilador.c.VarCmd;
import com.poli.compilador.c.VarDecl;
import com.poli.compilador.c.WhileCmd;
import com.poli.compilador.validation.AbstractCValidator;
import com.poli.compilador.validation.Validator;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class CValidator extends AbstractCValidator {
  @Check
  public void checkFunction(final Function F) {
    int _size = F.getParams().size();
    boolean _greaterThan = (_size > 4);
    if (_greaterThan) {
      this.error("Maximum number of parameters exceeded.", F, CPackage.Literals.FUNCTION__PARAMS);
      return;
    }
    final List<Command> commands = IteratorExtensions.<Command>toList(Iterators.<Command>filter(F.eAllContents(), Command.class));
    for (final Command c : commands) {
      if ((c instanceof ReturnCmd)) {
        if (((((ReturnCmd)c).getExp() == null) && (!Objects.equal(F.getTipo().getTipo(), "void")))) {
          this.error("Invalid return type.", c, CPackage.Literals.RETURN_CMD__EXP);
        }
        final Validator.Tipo tipo = Validator.tipode(((ReturnCmd)c).getExp(), null);
        if ((Objects.equal(tipo, Validator.Tipo.INT) && (!Objects.equal(F.getTipo().getTipo(), "int")))) {
          this.error("Invalid return type.", c, CPackage.Literals.RETURN_CMD__EXP);
        }
        if ((Objects.equal(tipo, Validator.Tipo.BOOL) && (!Objects.equal(F.getTipo().getTipo(), "bool")))) {
          this.error("Invalid return type.", c, CPackage.Literals.RETURN_CMD__EXP);
        }
        if ((Objects.equal(tipo, Validator.Tipo.STR) && (!Objects.equal(F.getTipo().getTipo(), "string")))) {
          this.error("Invalid return type.", c, CPackage.Literals.RETURN_CMD__EXP);
        }
      }
    }
  }
  
  @Check
  public void checkIf(final IfCmd c) {
    final Validator.Tipo tipo = Validator.tipode(c.getExp(), null);
    boolean _notEquals = (!Objects.equal(tipo, Validator.Tipo.BOOL));
    if (_notEquals) {
      this.error((("Condition must be a Bool. " + tipo) + " given."), c, CPackage.Literals.IF_CMD__EXP);
    }
  }
  
  @Check
  public void checkWhile(final WhileCmd c) {
    final Validator.Tipo tipo = Validator.tipode(c.getExp(), null);
    boolean _notEquals = (!Objects.equal(tipo, Validator.Tipo.BOOL));
    if (_notEquals) {
      this.error((("Condition must be a Bool. " + tipo) + " given."), c, CPackage.Literals.WHILE_CMD__EXP);
    }
  }
  
  @Check
  public void checkDoWhile(final DoWhileCmd c) {
    final Validator.Tipo tipo = Validator.tipode(c.getExp(), null);
    boolean _notEquals = (!Objects.equal(tipo, Validator.Tipo.BOOL));
    if (_notEquals) {
      this.error((("Condition must be a Bool. " + tipo) + " given."), c, CPackage.Literals.DO_WHILE_CMD__EXP);
    }
  }
  
  @Check
  public void checkSwitch(final SwitchCmd c) {
    final Validator.Tipo tipo = Validator.tipode(c.getExp(), null);
    if ((tipo == null)) {
      this.error("Invalid switch expression. ", c, CPackage.Literals.SWITCH_CMD__EXP);
    }
    EList<Case> _cases = c.getCases();
    for (final Case cs : _cases) {
      {
        Validator.Tipo tipoCase = Validator.tipode(cs.getVal(), null);
        boolean _notEquals = (!Objects.equal(tipoCase, tipo));
        if (_notEquals) {
          this.error("Invalid case type. ", c, CPackage.Literals.SWITCH_CMD__CASES);
        }
        Expression _val = cs.getVal();
        boolean _notEquals_1 = ((_val instanceof Literal) != true);
        if (_notEquals_1) {
          this.error("Invalid case. ", c, CPackage.Literals.SWITCH_CMD__CASES);
        }
      }
    }
  }
  
  @Check
  public void checkFor(final ForCmd c) {
    final Validator.Tipo tipo = Validator.tipode(c.getExp(), null);
    boolean _notEquals = (!Objects.equal(tipo, Validator.Tipo.BOOL));
    if (_notEquals) {
      this.error((("Condition must be a Bool. " + tipo) + " given."), c, CPackage.Literals.FOR_CMD__EXP);
    }
  }
  
  @Check
  public void checkVarCmd(final VarCmd C) {
    Assignment _asg = C.getAsg();
    boolean _tripleNotEquals = (_asg != null);
    if (_tripleNotEquals) {
      final Expression lval = C.getLval();
      final Expression asg = C.getAsg().getExp();
      Validator.Tipo tipoVar = Validator.tipode(lval, null);
      Validator.Tipo tipoAsg = Validator.tipode(asg, null);
      Validator.Tipo _tipode = Validator.tipode(lval, null);
      Validator.Tipo _tipode_1 = Validator.tipode(asg, null);
      boolean _notEquals = (!Objects.equal(_tipode, _tipode_1));
      if (_notEquals) {
        this.error(((("Incompatible assignment types. Expected: " + tipoVar) + " Got: ") + tipoAsg), C, CPackage.Literals.VAR_CMD__ASG);
      }
    }
  }
  
  @Check
  public void checkLValue(final Expression v) {
    if ((v instanceof FieldAccess)) {
      this.checkFieldAccess(((FieldAccess)v));
    }
    if ((v instanceof ArrayAccess)) {
      this.checkArrayAccess(((ArrayAccess)v));
    }
    if ((v instanceof FuncCall)) {
      this.checkFunctionCall(((FuncCall)v));
    }
  }
  
  public void checkFieldAccess(final FieldAccess v) {
    Expression _obj = v.getObj();
    final Var lvalue = ((Var) _obj);
    Definition _valor = lvalue.getValor();
    boolean _notEquals = ((_valor instanceof StrDecl) != true);
    if (_notEquals) {
      this.error("Illegal access. Not a Struct.", v, CPackage.Literals.FIELD_ACCESS__OBJ);
      return;
    }
    Definition _valor_1 = lvalue.getValor();
    final StrDecl strDecl = ((StrDecl) _valor_1);
    final Struct struct = strDecl.getStr();
    final EList<Declaration> decls = struct.getDecl();
    final String campo = v.getField();
    for (final Declaration d : decls) {
      String _name = d.getName();
      boolean _equals = Objects.equal(_name, campo);
      if (_equals) {
        return;
      }
    }
    this.error("Struct field not defined.", v, CPackage.Literals.FIELD_ACCESS__FIELD);
  }
  
  public void checkArrayAccess(final ArrayAccess v) {
    Expression _arr = v.getArr();
    final Var lvalue = ((Var) _arr);
    Definition _valor = lvalue.getValor();
    boolean _notEquals = ((_valor instanceof Declaration) != true);
    if (_notEquals) {
      return;
    }
    Definition _valor_1 = lvalue.getValor();
    final Declaration decl = ((Declaration) _valor_1);
    if (((decl instanceof VarDecl) != true)) {
      this.error("Illegal access. Not a variable.", v, CPackage.Literals.ARRAY_ACCESS__ARR);
      return;
    }
    final Type tipo = ((VarDecl) decl).getTipo();
    Expression _exp = tipo.getExp();
    boolean _tripleEquals = (_exp == null);
    if (_tripleEquals) {
      this.error("Illegal access. Not an Array.", v, CPackage.Literals.ARRAY_ACCESS__INDEX);
      return;
    }
    final Expression index = v.getIndex();
    Validator.Tipo _tipode = Validator.tipode(index, null);
    boolean _notEquals_1 = (!Objects.equal(_tipode, Validator.Tipo.INT));
    if (_notEquals_1) {
      this.error("Illegal access. Non integer index.", v, CPackage.Literals.ARRAY_ACCESS__INDEX);
      return;
    }
    if ((index instanceof Var)) {
      return;
    }
    if (((((IntLit) tipo.getExp()).getVal() < (((IntLit) index).getVal() + 1)) || (((IntLit) index).getVal() < 0))) {
      this.error("Array out of bounds.", v, CPackage.Literals.ARRAY_ACCESS__INDEX);
      return;
    }
  }
  
  public void checkFunctionCall(final FuncCall F) {
    Expression _def = F.getDef();
    final Definition def = ((Var) _def).getValor();
    EList<Declaration> _xifexpression = null;
    if ((def instanceof Function)) {
      _xifexpression = ((Function) def).getParams();
    } else {
      return;
    }
    final EList<Declaration> params = _xifexpression;
    final EList<Expression> args = F.getArg().getExp();
    int _size = params.size();
    int _size_1 = args.size();
    boolean _notEquals = (_size != _size_1);
    if (_notEquals) {
      this.error("Wrong number of arguments.", F, CPackage.Literals.FUNC_CALL__ARG);
      return;
    }
    for (int i = 0; (i < params.size()); i++) {
      {
        final Validator.Tipo tipoA = Validator.tipode(args.get(i), null);
        Declaration _get = params.get(i);
        final Type tipoP = ((VarDecl) _get).getTipo();
        if ((Objects.equal(tipoP.getTipo(), "int") && (!Objects.equal(tipoA, Validator.Tipo.INT)))) {
          this.error("Invalid argument type.", F, CPackage.Literals.FUNC_CALL__ARG);
          return;
        } else {
          if ((Objects.equal(tipoP.getTipo(), "bool") && (!Objects.equal(tipoA, Validator.Tipo.BOOL)))) {
            this.error("Invalid argument type.", F, CPackage.Literals.FUNC_CALL__ARG);
            return;
          } else {
            if ((Objects.equal(tipoP.getTipo(), "string") && (!Objects.equal(tipoA, Validator.Tipo.STR)))) {
              this.error("Invalid argument type.", F, CPackage.Literals.FUNC_CALL__ARG);
              return;
            }
          }
        }
      }
    }
  }
}
