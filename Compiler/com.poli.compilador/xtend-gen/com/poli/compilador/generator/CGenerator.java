/**
 * generated by Xtext 2.12.0
 */
package com.poli.compilador.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterators;
import com.poli.compilador.c.Argument;
import com.poli.compilador.c.ArithExp;
import com.poli.compilador.c.ArrayAccess;
import com.poli.compilador.c.Assignment;
import com.poli.compilador.c.BreakCmd;
import com.poli.compilador.c.Case;
import com.poli.compilador.c.Command;
import com.poli.compilador.c.ContinueCmd;
import com.poli.compilador.c.DeclCmd;
import com.poli.compilador.c.Declaration;
import com.poli.compilador.c.Definition;
import com.poli.compilador.c.DoWhileCmd;
import com.poli.compilador.c.Expression;
import com.poli.compilador.c.FalseLit;
import com.poli.compilador.c.FieldAccess;
import com.poli.compilador.c.ForCmd;
import com.poli.compilador.c.FuncCall;
import com.poli.compilador.c.Function;
import com.poli.compilador.c.IfCmd;
import com.poli.compilador.c.IntLit;
import com.poli.compilador.c.LogicExp;
import com.poli.compilador.c.Parenteses;
import com.poli.compilador.c.PointerExp;
import com.poli.compilador.c.PostfixOp;
import com.poli.compilador.c.PrefixOp;
import com.poli.compilador.c.PrintCmd;
import com.poli.compilador.c.Program;
import com.poli.compilador.c.RelExp;
import com.poli.compilador.c.ReturnCmd;
import com.poli.compilador.c.StrLit;
import com.poli.compilador.c.Struct;
import com.poli.compilador.c.SwitchCmd;
import com.poli.compilador.c.Term;
import com.poli.compilador.c.TrueLit;
import com.poli.compilador.c.Type;
import com.poli.compilador.c.Var;
import com.poli.compilador.c.VarCmd;
import com.poli.compilador.c.VarDecl;
import com.poli.compilador.c.WhileCmd;
import com.poli.compilador.validation.Validator;
import java.util.HashMap;
import java.util.Stack;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.Pair;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class CGenerator extends AbstractGenerator {
  public int label;
  
  public int index;
  
  public Stack<String> globals;
  
  public Stack<String> fName;
  
  public Stack<Pair<String, String>> loops;
  
  public HashMap<String, Integer> locals;
  
  public HashMap<String, Integer> params;
  
  public HashMap<String, Integer> init() {
    HashMap<String, Integer> _xblockexpression = null;
    {
      this.label = 0;
      this.index = 0;
      Stack<String> _stack = new Stack<String>();
      this.globals = _stack;
      Stack<String> _stack_1 = new Stack<String>();
      this.fName = _stack_1;
      Stack<Pair<String, String>> _stack_2 = new Stack<Pair<String, String>>();
      this.loops = _stack_2;
      HashMap<String, Integer> _hashMap = new HashMap<String, Integer>();
      this.locals = _hashMap;
      HashMap<String, Integer> _hashMap_1 = new HashMap<String, Integer>();
      _xblockexpression = this.params = _hashMap_1;
    }
    return _xblockexpression;
  }
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    Program p = IteratorExtensions.<Program>head(Iterators.<Program>filter(resource.getAllContents(), Program.class));
    String filename = resource.getURI().lastSegment().split("\\.")[0];
    if ((p == null)) {
      return;
    }
    this.init();
    fsa.generateFile((filename + ".asm"), this.compile(p));
  }
  
  public CharSequence compile(final Program P) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.newLine();
    {
      EList<Definition> _definition = P.getDefinition();
      for(final Definition D : _definition) {
        Object _definition_1 = this.definition(D);
        _builder.append(_definition_1);
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("exit:");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("li $v0, 10");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("syscall");
    _builder.newLine();
    return _builder;
  }
  
  public Object definition(final Definition D) {
    Object _switchResult = null;
    boolean _matched = false;
    if ((D instanceof Function)) {
      _matched=true;
      _switchResult = this.function(((Function) D));
    }
    if (!_matched) {
      if ((D instanceof Declaration)) {
        _matched=true;
        _switchResult = this.declaration(((Declaration) D));
      }
    }
    if (!_matched) {
      if ((D instanceof Struct)) {
        _matched=true;
        _switchResult = this.struct(((Struct) D));
      }
    }
    return _switchResult;
  }
  
  public Object struct(final Struct S) {
    return null;
  }
  
  public String declaration(final Declaration D) {
    if ((D instanceof VarDecl)) {
      StringConcatenation _builder = new StringConcatenation();
      String mips = _builder.toString();
      this.index++;
      String _name = ((VarDecl)D).getName();
      final String vName = (_name + Integer.valueOf(this.index));
      int size = 4;
      this.globals.add(vName);
      String _tipo = ((VarDecl)D).getTipo().getTipo();
      boolean _equals = Objects.equal(_tipo, "string");
      if (_equals) {
        String _xifexpression = null;
        Assignment _val = ((VarDecl)D).getVal();
        boolean _tripleEquals = (_val == null);
        if (_tripleEquals) {
          _xifexpression = "";
        } else {
          Expression _exp = ((VarDecl)D).getVal().getExp();
          _xifexpression = ((StrLit) _exp).getVal();
        }
        String content = _xifexpression;
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append(".data");
        _builder_1.newLine();
        _builder_1.append("_");
        _builder_1.append(vName);
        _builder_1.append(": .asciiz \"");
        _builder_1.append(content);
        _builder_1.append("\"");
        _builder_1.newLineIfNotEmpty();
        _builder_1.newLine();
        mips = _builder_1.toString();
        return mips;
      }
      Expression _exp_1 = ((VarDecl)D).getTipo().getExp();
      boolean _tripleNotEquals = (_exp_1 != null);
      if (_tripleNotEquals) {
        final Expression arrIdx = ((VarDecl)D).getTipo().getExp();
        final int arrSize = ((IntLit) arrIdx).getVal();
        size = (arrSize * 4);
      }
      StringConcatenation _builder_2 = new StringConcatenation();
      _builder_2.append(".data");
      _builder_2.newLine();
      _builder_2.append(".align 2");
      _builder_2.newLine();
      _builder_2.append("_");
      _builder_2.append(vName);
      _builder_2.append(": .space ");
      _builder_2.append(size);
      _builder_2.newLineIfNotEmpty();
      {
        Assignment _val_1 = ((VarDecl)D).getVal();
        boolean _tripleNotEquals_1 = (_val_1 != null);
        if (_tripleNotEquals_1) {
          _builder_2.append(".text");
          _builder_2.newLine();
          CharSequence _assign = this.assign(((VarDecl)D).getVal());
          _builder_2.append(_assign);
          _builder_2.newLineIfNotEmpty();
          CharSequence _pop = this.pop("t9");
          _builder_2.append(_pop);
          _builder_2.newLineIfNotEmpty();
          _builder_2.append("sw\t\t$t9, _");
          _builder_2.append(vName);
          _builder_2.newLineIfNotEmpty();
        }
      }
      _builder_2.newLine();
      mips = _builder_2.toString();
      return mips;
    }
    return null;
  }
  
  public String function(final Function F) {
    this.fName.push(F.getName());
    this.globals.add(F.getName());
    final int paramSize = this.getParamSize(F.getParams());
    final int localSize = 12;
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(".text");
    _builder.newLine();
    _builder.append(".align 2");
    _builder.newLine();
    {
      boolean _equals = F.getName().equals("main");
      if (_equals) {
        _builder.append(".globl main");
        _builder.newLine();
        String _name = F.getName();
        _builder.append(_name);
        _builder.append(":");
        _builder.newLineIfNotEmpty();
      } else {
        _builder.append("_");
        String _name_1 = F.getName();
        _builder.append(_name_1);
        _builder.append(":");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t");
    CharSequence _functionEntry = this.functionEntry(paramSize, localSize);
    _builder.append(_functionEntry, "\t");
    _builder.newLineIfNotEmpty();
    {
      EList<Command> _commands = F.getCommands();
      for(final Command C : _commands) {
        _builder.append("\t");
        CharSequence _command = this.command(C);
        _builder.append(_command, "\t");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("    ");
    CharSequence _functionExit = this.functionExit(paramSize);
    _builder.append(_functionExit, "    ");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    String mips = _builder.toString();
    return mips;
  }
  
  public CharSequence command(final Command C) {
    CharSequence _switchResult = null;
    boolean _matched = false;
    if ((C instanceof PrintCmd)) {
      _matched=true;
      _switchResult = this.printCommand(((PrintCmd) C));
    }
    if (!_matched) {
      if ((C instanceof IfCmd)) {
        _matched=true;
        _switchResult = this.ifCommand(((IfCmd) C));
      }
    }
    if (!_matched) {
      if ((C instanceof WhileCmd)) {
        _matched=true;
        _switchResult = this.whileCommand(((WhileCmd) C));
      }
    }
    if (!_matched) {
      if ((C instanceof ForCmd)) {
        _matched=true;
        _switchResult = this.forCommand(((ForCmd) C));
      }
    }
    if (!_matched) {
      if ((C instanceof SwitchCmd)) {
        _matched=true;
        _switchResult = this.switchCommand(((SwitchCmd) C));
      }
    }
    if (!_matched) {
      if ((C instanceof DoWhileCmd)) {
        _matched=true;
        _switchResult = this.doWhileCommand(((DoWhileCmd) C));
      }
    }
    if (!_matched) {
      if ((C instanceof VarCmd)) {
        _matched=true;
        _switchResult = this.varCommand(((VarCmd) C));
      }
    }
    if (!_matched) {
      if ((C instanceof BreakCmd)) {
        _matched=true;
        _switchResult = this.breakCommand(((BreakCmd) C));
      }
    }
    if (!_matched) {
      if ((C instanceof ContinueCmd)) {
        _matched=true;
        _switchResult = this.continueCommand(((ContinueCmd) C));
      }
    }
    if (!_matched) {
      if ((C instanceof ReturnCmd)) {
        _matched=true;
        _switchResult = this.returnCommand(((ReturnCmd) C));
      }
    }
    if (!_matched) {
      if ((C instanceof DeclCmd)) {
        _matched=true;
        _switchResult = this.declCommand(((DeclCmd) C));
      }
    }
    return _switchResult;
  }
  
  public String switchCommand(final SwitchCmd C) {
    StringConcatenation _builder = new StringConcatenation();
    String mips = _builder.toString();
    Stack<String> caseLabel = new Stack<String>();
    String _nextLabel = this.nextLabel();
    String end = (_nextLabel + "_endswitch");
    Pair<String, String> _pair = new Pair<String, String>("", end);
    this.loops.push(_pair);
    String _mips = mips;
    StringConcatenation _builder_1 = new StringConcatenation();
    CharSequence _expression = this.expression(C.getExp());
    _builder_1.append(_expression);
    _builder_1.newLineIfNotEmpty();
    CharSequence _pop = this.pop("t0");
    _builder_1.append(_pop);
    _builder_1.newLineIfNotEmpty();
    {
      EList<Case> _cases = C.getCases();
      for(final Case cs : _cases) {
        String _nextLabel_1 = this.nextLabel();
        String _plus = (_nextLabel_1 + "_switch");
        final String label = caseLabel.push(_plus);
        _builder_1.newLineIfNotEmpty();
        Validator.Tipo tipo = Validator.tipode(cs.getVal(), null);
        _builder_1.newLineIfNotEmpty();
        {
          boolean _equals = Objects.equal(tipo, Validator.Tipo.INT);
          if (_equals) {
            _builder_1.append("beq $t0, ");
            Expression _val = cs.getVal();
            int _val_1 = ((IntLit) _val).getVal();
            _builder_1.append(_val_1);
            _builder_1.append(", ");
            _builder_1.append(label);
            _builder_1.newLineIfNotEmpty();
          } else {
            if ((Objects.equal(tipo, Validator.Tipo.BOOL) && (cs.getVal() instanceof TrueLit))) {
              _builder_1.append("bne $t0, $0, ");
              _builder_1.append(label);
              _builder_1.newLineIfNotEmpty();
            } else {
              if ((Objects.equal(tipo, Validator.Tipo.BOOL) && (cs.getVal() instanceof FalseLit))) {
                _builder_1.append("beq $t0, $0, ");
                _builder_1.append(label);
                _builder_1.newLineIfNotEmpty();
              }
            }
          }
        }
      }
    }
    String _nextLabel_2 = this.nextLabel();
    final String defLabel = (_nextLabel_2 + "_default");
    _builder_1.newLineIfNotEmpty();
    _builder_1.append("j ");
    _builder_1.append(defLabel);
    _builder_1.newLineIfNotEmpty();
    _builder_1.newLine();
    String _xblockexpression = null;
    {
      caseLabel = this.orderStack(caseLabel);
      _xblockexpression = "";
    }
    _builder_1.append(_xblockexpression);
    _builder_1.newLineIfNotEmpty();
    {
      EList<Case> _cases_1 = C.getCases();
      for(final Case cs_1 : _cases_1) {
        String _pop_1 = caseLabel.pop();
        _builder_1.append(_pop_1);
        _builder_1.append(":");
        _builder_1.newLineIfNotEmpty();
        {
          EList<Command> _commands = cs_1.getCommands();
          for(final Command cmd : _commands) {
            _builder_1.append("\t");
            CharSequence _command = this.command(cmd);
            _builder_1.append(_command, "\t");
            _builder_1.newLineIfNotEmpty();
          }
        }
      }
    }
    {
      EList<Command> _defaultCmds = C.getDefaultCmds();
      for(final Command defCmd : _defaultCmds) {
        _builder_1.append(defLabel);
        _builder_1.append(":");
        _builder_1.newLineIfNotEmpty();
        _builder_1.append("\t");
        CharSequence _command_1 = this.command(defCmd);
        _builder_1.append(_command_1, "\t");
        _builder_1.newLineIfNotEmpty();
      }
    }
    _builder_1.append(end);
    _builder_1.append(":");
    _builder_1.newLineIfNotEmpty();
    mips = (_mips + _builder_1);
    this.loops.pop();
    return mips;
  }
  
  public String declCommand(final DeclCmd C) {
    StringConcatenation _builder = new StringConcatenation();
    String mips = _builder.toString();
    final String vName = C.getVal().getName();
    final Declaration decl = C.getVal();
    this.locals.put(vName, Integer.valueOf(this.index));
    if ((decl instanceof VarDecl)) {
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("# ");
      _builder_1.append(vName);
      _builder_1.newLineIfNotEmpty();
      {
        Assignment _val = ((VarDecl)decl).getVal();
        boolean _tripleNotEquals = (_val != null);
        if (_tripleNotEquals) {
          CharSequence _expression = this.expression(((VarDecl)decl).getVal().getExp());
          _builder_1.append(_expression);
          _builder_1.newLineIfNotEmpty();
          CharSequence _pop = this.pop("t7");
          _builder_1.append(_pop);
          _builder_1.newLineIfNotEmpty();
          _builder_1.append("sw\t\t$t7, -");
          _builder_1.append((this.index + 4));
          _builder_1.append("($fp)");
          _builder_1.newLineIfNotEmpty();
          _builder_1.newLine();
        }
      }
      mips = _builder_1.toString();
    }
    int _index = this.index;
    this.index = (_index + 4);
    return mips;
  }
  
  public String breakCommand(final BreakCmd C) {
    final String endloop = this.loops.peek().getValue();
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("j ");
    _builder.append(endloop);
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    final String mips = _builder.toString();
    return mips;
  }
  
  public String continueCommand(final ContinueCmd C) {
    final String startloop = this.loops.peek().getKey();
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("j ");
    _builder.append(startloop);
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    final String mips = _builder.toString();
    return mips;
  }
  
  public String forCommand(final ForCmd C) {
    StringConcatenation _builder = new StringConcatenation();
    String mips = _builder.toString();
    String _nextLabel = this.nextLabel();
    final String start = (_nextLabel + "_for");
    String _nextLabel_1 = this.nextLabel();
    final String end = (_nextLabel_1 + "_endfor");
    Pair<String, String> _pair = new Pair<String, String>(start, end);
    this.loops.push(_pair);
    String _mips = mips;
    StringConcatenation _builder_1 = new StringConcatenation();
    CharSequence _assign = this.assign(C.getInitAsg());
    _builder_1.append(_assign);
    _builder_1.newLineIfNotEmpty();
    CharSequence _store = this.store(C.getInit());
    _builder_1.append(_store);
    _builder_1.newLineIfNotEmpty();
    _builder_1.append(start);
    _builder_1.append(":");
    _builder_1.newLineIfNotEmpty();
    CharSequence _expression = this.expression(C.getExp());
    _builder_1.append(_expression);
    _builder_1.newLineIfNotEmpty();
    CharSequence _pop = this.pop("t0");
    _builder_1.append(_pop);
    _builder_1.newLineIfNotEmpty();
    _builder_1.append("beq\t\t$t0, $0, ");
    _builder_1.append(end);
    _builder_1.newLineIfNotEmpty();
    {
      EList<Command> _commands = C.getCommands();
      for(final Command c : _commands) {
        CharSequence _command = this.command(c);
        _builder_1.append(_command);
        _builder_1.newLineIfNotEmpty();
      }
    }
    {
      Assignment _incAsg = C.getIncAsg();
      boolean _tripleNotEquals = (_incAsg != null);
      if (_tripleNotEquals) {
        CharSequence _assign_1 = this.assign(C.getIncAsg());
        _builder_1.append(_assign_1);
        _builder_1.newLineIfNotEmpty();
        CharSequence _store_1 = this.store(C.getInc());
        _builder_1.append(_store_1);
        _builder_1.newLineIfNotEmpty();
      } else {
        CharSequence _expression_1 = this.expression(C.getInc());
        _builder_1.append(_expression_1);
        _builder_1.newLineIfNotEmpty();
      }
    }
    _builder_1.append("j ");
    _builder_1.append(start);
    _builder_1.newLineIfNotEmpty();
    _builder_1.append(end);
    _builder_1.append(":");
    _builder_1.newLineIfNotEmpty();
    _builder_1.newLine();
    mips = (_mips + _builder_1);
    this.loops.pop();
    return mips;
  }
  
  public String whileCommand(final WhileCmd C) {
    StringConcatenation _builder = new StringConcatenation();
    String mips = _builder.toString();
    String _nextLabel = this.nextLabel();
    final String start = (_nextLabel + "_while");
    String _nextLabel_1 = this.nextLabel();
    final String end = (_nextLabel_1 + "_endwhile");
    Pair<String, String> _pair = new Pair<String, String>(start, end);
    this.loops.push(_pair);
    String _mips = mips;
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append(start);
    _builder_1.append(":");
    _builder_1.newLineIfNotEmpty();
    CharSequence _expression = this.expression(C.getExp());
    _builder_1.append(_expression);
    _builder_1.newLineIfNotEmpty();
    CharSequence _pop = this.pop("t0");
    _builder_1.append(_pop);
    _builder_1.newLineIfNotEmpty();
    _builder_1.append("beq\t\t$t0, $0, ");
    _builder_1.append(end);
    _builder_1.newLineIfNotEmpty();
    {
      EList<Command> _commands = C.getCommands();
      for(final Command c : _commands) {
        CharSequence _command = this.command(c);
        _builder_1.append(_command);
        _builder_1.newLineIfNotEmpty();
      }
    }
    _builder_1.append("j ");
    _builder_1.append(start);
    _builder_1.newLineIfNotEmpty();
    _builder_1.append(end);
    _builder_1.append(":");
    _builder_1.newLineIfNotEmpty();
    _builder_1.newLine();
    mips = (_mips + _builder_1);
    this.loops.pop();
    return mips;
  }
  
  public String doWhileCommand(final DoWhileCmd C) {
    StringConcatenation _builder = new StringConcatenation();
    String mips = _builder.toString();
    String _nextLabel = this.nextLabel();
    final String start = (_nextLabel + "_dowhile");
    String _nextLabel_1 = this.nextLabel();
    final String end = (_nextLabel_1 + "_enddowhile");
    Pair<String, String> _pair = new Pair<String, String>(start, end);
    this.loops.push(_pair);
    String _mips = mips;
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append(start);
    _builder_1.append(":");
    _builder_1.newLineIfNotEmpty();
    {
      EList<Command> _commands = C.getCommands();
      for(final Command c : _commands) {
        CharSequence _command = this.command(c);
        _builder_1.append(_command);
        _builder_1.newLineIfNotEmpty();
      }
    }
    CharSequence _expression = this.expression(C.getExp());
    _builder_1.append(_expression);
    _builder_1.newLineIfNotEmpty();
    CharSequence _pop = this.pop("t0");
    _builder_1.append(_pop);
    _builder_1.newLineIfNotEmpty();
    _builder_1.append("bne\t\t$t0, $0, ");
    _builder_1.append(start);
    _builder_1.newLineIfNotEmpty();
    _builder_1.append("end");
    _builder_1.newLine();
    _builder_1.newLine();
    mips = (_mips + _builder_1);
    this.loops.pop();
    return mips;
  }
  
  public CharSequence printCommand(final PrintCmd C) {
    StringConcatenation _builder = new StringConcatenation();
    String mips = _builder.toString();
    final Validator.Tipo tipo = Validator.tipode(C.getExp(), null);
    String _mips = mips;
    StringConcatenation _builder_1 = new StringConcatenation();
    CharSequence _expression = this.expression(C.getExp());
    _builder_1.append(_expression);
    _builder_1.newLineIfNotEmpty();
    CharSequence _pop = this.pop("a0");
    _builder_1.append(_pop);
    _builder_1.newLineIfNotEmpty();
    {
      if (((Objects.equal(tipo, Validator.Tipo.INT) || Objects.equal(tipo, Validator.Tipo.BOOL)) || (tipo == null))) {
        _builder_1.append("li\t\t$v0, 1");
        _builder_1.newLine();
      } else {
        boolean _equals = Objects.equal(tipo, Validator.Tipo.STR);
        if (_equals) {
          _builder_1.append("li\t\t$v0, 4");
          _builder_1.newLine();
        }
      }
    }
    _builder_1.append("syscall");
    _builder_1.newLine();
    _builder_1.newLine();
    mips = (_mips + _builder_1);
    return mips;
  }
  
  public CharSequence ifCommand(final IfCmd C) {
    StringConcatenation _builder = new StringConcatenation();
    String mips = _builder.toString();
    final String label = this.nextLabel();
    final String falsel = (label + "_FALSE");
    final String truel = (label + "_TRUE");
    String _mips = mips;
    StringConcatenation _builder_1 = new StringConcatenation();
    CharSequence _expression = this.expression(C.getExp());
    _builder_1.append(_expression);
    _builder_1.newLineIfNotEmpty();
    CharSequence _pop = this.pop("t0");
    _builder_1.append(_pop);
    _builder_1.newLineIfNotEmpty();
    _builder_1.append("beq\t\t$t0, $0, ");
    _builder_1.append(falsel);
    _builder_1.newLineIfNotEmpty();
    {
      EList<Command> _trueCommands = C.getTrueCommands();
      for(final Command tc : _trueCommands) {
        CharSequence _command = this.command(tc);
        _builder_1.append(_command);
        _builder_1.newLineIfNotEmpty();
      }
    }
    _builder_1.append("j ");
    _builder_1.append(truel);
    _builder_1.newLineIfNotEmpty();
    _builder_1.newLine();
    _builder_1.append(falsel);
    _builder_1.append(":");
    _builder_1.newLineIfNotEmpty();
    {
      EList<Command> _falseCommands = C.getFalseCommands();
      boolean _tripleNotEquals = (_falseCommands != null);
      if (_tripleNotEquals) {
        {
          EList<Command> _falseCommands_1 = C.getFalseCommands();
          for(final Command fc : _falseCommands_1) {
            CharSequence _command_1 = this.command(fc);
            _builder_1.append(_command_1);
            _builder_1.newLineIfNotEmpty();
          }
        }
      }
    }
    _builder_1.append(truel);
    _builder_1.append(":");
    _builder_1.newLineIfNotEmpty();
    _builder_1.newLine();
    mips = (_mips + _builder_1);
    return mips;
  }
  
  public String returnCommand(final ReturnCmd C) {
    StringConcatenation _builder = new StringConcatenation();
    String mips = _builder.toString();
    String _mips = mips;
    StringConcatenation _builder_1 = new StringConcatenation();
    {
      Expression _exp = C.getExp();
      boolean _tripleNotEquals = (_exp != null);
      if (_tripleNotEquals) {
        CharSequence _expression = this.expression(C.getExp());
        _builder_1.append(_expression);
        _builder_1.newLineIfNotEmpty();
        CharSequence _pop = this.pop("v0");
        _builder_1.append(_pop);
        _builder_1.newLineIfNotEmpty();
      }
    }
    _builder_1.append("j ");
    String _peek = this.fName.peek();
    _builder_1.append(_peek);
    _builder_1.append("_return");
    _builder_1.newLineIfNotEmpty();
    _builder_1.newLine();
    mips = (_mips + _builder_1);
    return mips;
  }
  
  public String varCommand(final VarCmd V) {
    StringConcatenation _builder = new StringConcatenation();
    String mips = _builder.toString();
    Assignment _asg = V.getAsg();
    boolean _tripleNotEquals = (_asg != null);
    if (_tripleNotEquals) {
      String _mips = mips;
      StringConcatenation _builder_1 = new StringConcatenation();
      CharSequence _assign = this.assign(V.getAsg());
      _builder_1.append(_assign);
      _builder_1.newLineIfNotEmpty();
      {
        Expression _lval = V.getLval();
        if ((_lval instanceof ArrayAccess)) {
          Expression _lval_1 = V.getLval();
          String _storeArray = this.storeArray(((ArrayAccess) _lval_1));
          _builder_1.append(_storeArray);
          _builder_1.newLineIfNotEmpty();
        } else {
          CharSequence _store = this.store(V.getLval());
          _builder_1.append(_store);
          _builder_1.newLineIfNotEmpty();
        }
      }
      mips = (_mips + _builder_1);
      return mips;
    }
    String _mips_1 = mips;
    StringConcatenation _builder_2 = new StringConcatenation();
    CharSequence _expression = this.expression(V.getLval());
    _builder_2.append(_expression);
    _builder_2.newLineIfNotEmpty();
    CharSequence _pop = this.pop("v0");
    _builder_2.append(_pop);
    _builder_2.newLineIfNotEmpty();
    _builder_2.newLine();
    mips = (_mips_1 + _builder_2);
    return mips;
  }
  
  public CharSequence assign(final Assignment A) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _expression = this.expression(A.getExp());
    _builder.append(_expression);
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence expression(final Expression E) {
    StringConcatenation _builder = new StringConcatenation();
    String mips = _builder.toString();
    if ((E instanceof ArithExp)) {
      boolean _equalsIgnoreCase = ((ArithExp)E).getOp().equalsIgnoreCase("+");
      if (_equalsIgnoreCase) {
        String _mips = mips;
        String _arithExp = this.arithExp(((ArithExp)E), "add");
        mips = (_mips + _arithExp);
      }
      boolean _equalsIgnoreCase_1 = ((ArithExp)E).getOp().equalsIgnoreCase("-");
      if (_equalsIgnoreCase_1) {
        String _mips_1 = mips;
        String _arithExp_1 = this.arithExp(((ArithExp)E), "sub");
        mips = (_mips_1 + _arithExp_1);
      }
      return mips;
    }
    if ((E instanceof Term)) {
      boolean _equalsIgnoreCase_2 = ((Term)E).getOp().equalsIgnoreCase("*");
      if (_equalsIgnoreCase_2) {
        String _mips_2 = mips;
        String _termExp = this.termExp(((Term)E), "mul");
        mips = (_mips_2 + _termExp);
      }
      boolean _equalsIgnoreCase_3 = ((Term)E).getOp().equalsIgnoreCase("/");
      if (_equalsIgnoreCase_3) {
        String _mips_3 = mips;
        String _termExp_1 = this.termExp(((Term)E), "div");
        mips = (_mips_3 + _termExp_1);
      }
      return mips;
    }
    if ((E instanceof RelExp)) {
      boolean _equalsIgnoreCase_4 = ((RelExp)E).getOp().equalsIgnoreCase(">");
      if (_equalsIgnoreCase_4) {
        String _mips_4 = mips;
        String _relExp = this.relExp(((RelExp)E), "sgt");
        mips = (_mips_4 + _relExp);
      }
      boolean _equalsIgnoreCase_5 = ((RelExp)E).getOp().equalsIgnoreCase(">=");
      if (_equalsIgnoreCase_5) {
        String _mips_5 = mips;
        String _relExp_1 = this.relExp(((RelExp)E), "sge");
        mips = (_mips_5 + _relExp_1);
      }
      boolean _equalsIgnoreCase_6 = ((RelExp)E).getOp().equalsIgnoreCase("<");
      if (_equalsIgnoreCase_6) {
        String _mips_6 = mips;
        String _relExp_2 = this.relExp(((RelExp)E), "slt");
        mips = (_mips_6 + _relExp_2);
      }
      boolean _equalsIgnoreCase_7 = ((RelExp)E).getOp().equalsIgnoreCase("<=");
      if (_equalsIgnoreCase_7) {
        String _mips_7 = mips;
        String _relExp_3 = this.relExp(((RelExp)E), "sle");
        mips = (_mips_7 + _relExp_3);
      }
      boolean _equalsIgnoreCase_8 = ((RelExp)E).getOp().equalsIgnoreCase("==");
      if (_equalsIgnoreCase_8) {
        String _mips_8 = mips;
        String _relExp_4 = this.relExp(((RelExp)E), "seq");
        mips = (_mips_8 + _relExp_4);
      }
      boolean _equalsIgnoreCase_9 = ((RelExp)E).getOp().equalsIgnoreCase("!=");
      if (_equalsIgnoreCase_9) {
        String _mips_9 = mips;
        String _relExp_5 = this.relExp(((RelExp)E), "sne");
        mips = (_mips_9 + _relExp_5);
      }
      return mips;
    }
    if ((E instanceof LogicExp)) {
      boolean _equalsIgnoreCase_10 = ((LogicExp)E).getOp().equalsIgnoreCase("&&");
      if (_equalsIgnoreCase_10) {
        String _mips_10 = mips;
        String _logicExp = this.logicExp(((LogicExp)E), "and");
        mips = (_mips_10 + _logicExp);
      }
      boolean _equalsIgnoreCase_11 = ((LogicExp)E).getOp().equalsIgnoreCase("||");
      if (_equalsIgnoreCase_11) {
        String _mips_11 = mips;
        String _logicExp_1 = this.logicExp(((LogicExp)E), "or");
        mips = (_mips_11 + _logicExp_1);
      }
    }
    if ((E instanceof PostfixOp)) {
      final String op = ((PostfixOp)E).getUo();
      Expression _arg = ((PostfixOp)E).getArg();
      if ((_arg instanceof Var)) {
        Expression _arg_1 = ((PostfixOp)E).getArg();
        final String vName = ((Var) _arg_1).getValor().getName();
        final String id = this.getReference(vName);
        String _mips_12 = mips;
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("lw\t\t$t9, ");
        _builder_1.append(id);
        _builder_1.newLineIfNotEmpty();
        CharSequence _push = this.push("t9");
        _builder_1.append(_push);
        _builder_1.newLineIfNotEmpty();
        {
          boolean _equals = Objects.equal(op, "++");
          if (_equals) {
            _builder_1.append("addiu\t$t9, $t9, 1");
            _builder_1.newLine();
          } else {
            boolean _equals_1 = Objects.equal(op, "--");
            if (_equals_1) {
              _builder_1.append("addiu\t$t9, $t9, -1");
              _builder_1.newLine();
            }
          }
        }
        _builder_1.append("sw\t\t$t9, ");
        _builder_1.append(id);
        _builder_1.newLineIfNotEmpty();
        _builder_1.newLine();
        mips = (_mips_12 + _builder_1);
      }
      return mips;
    }
    if ((E instanceof PrefixOp)) {
      final String op_1 = ((PrefixOp)E).getUo();
      Expression _arg_2 = ((PrefixOp)E).getArg();
      if ((_arg_2 instanceof Var)) {
        Expression _arg_3 = ((PrefixOp)E).getArg();
        final String vName_1 = ((Var) _arg_3).getValor().getName();
        final String id_1 = this.getReference(vName_1);
        String _mips_13 = mips;
        StringConcatenation _builder_2 = new StringConcatenation();
        _builder_2.append("lw\t\t$t9, ");
        _builder_2.append(id_1);
        _builder_2.newLineIfNotEmpty();
        {
          boolean _equals_2 = Objects.equal(op_1, "++");
          if (_equals_2) {
            _builder_2.append("addiu\t$t9, $t9, 1");
            _builder_2.newLine();
          } else {
            boolean _equals_3 = Objects.equal(op_1, "--");
            if (_equals_3) {
              _builder_2.append("addiu\t$t9, $t9, -1");
              _builder_2.newLine();
            }
          }
        }
        _builder_2.append("sw\t\t$t9, ");
        _builder_2.append(id_1);
        _builder_2.newLineIfNotEmpty();
        CharSequence _push_1 = this.push("t9");
        _builder_2.append(_push_1);
        _builder_2.newLineIfNotEmpty();
        _builder_2.newLine();
        mips = (_mips_13 + _builder_2);
      }
      return mips;
    }
    if ((E instanceof Parenteses)) {
      return this.expression(((Parenteses)E).getExp());
    }
    if ((E instanceof FuncCall)) {
      Expression _def = ((FuncCall)E).getDef();
      final Var func = ((Var) _def);
      String _xifexpression = null;
      String _name = func.getValor().getName();
      boolean _equals_4 = Objects.equal(_name, "main");
      if (_equals_4) {
        _xifexpression = func.getValor().getName();
      } else {
        String _name_1 = func.getValor().getName();
        _xifexpression = ("_" + _name_1);
      }
      final String funcName = _xifexpression;
      String _mips_14 = mips;
      StringConcatenation _builder_3 = new StringConcatenation();
      int argNum = 0;
      _builder_3.newLineIfNotEmpty();
      {
        Argument _arg_4 = ((FuncCall)E).getArg();
        boolean _tripleNotEquals = (_arg_4 != null);
        if (_tripleNotEquals) {
          {
            EList<Expression> _exp = ((FuncCall)E).getArg().getExp();
            for(final Expression arg : _exp) {
              CharSequence _expression = this.expression(arg);
              _builder_3.append(_expression);
              _builder_3.newLineIfNotEmpty();
              CharSequence _pop = this.pop("t0");
              _builder_3.append(_pop);
              _builder_3.newLineIfNotEmpty();
              _builder_3.append("move\t\t$a");
              int _plusPlus = argNum++;
              _builder_3.append(_plusPlus);
              _builder_3.append(", $t0");
              _builder_3.newLineIfNotEmpty();
            }
          }
          _builder_3.newLine();
        }
      }
      CharSequence _jumpLink = this.jumpLink(funcName);
      _builder_3.append(_jumpLink);
      _builder_3.newLineIfNotEmpty();
      CharSequence _push_2 = this.push("v0");
      _builder_3.append(_push_2);
      _builder_3.newLineIfNotEmpty();
      _builder_3.newLine();
      mips = (_mips_14 + _builder_3);
      return mips;
    }
    if ((E instanceof ArrayAccess)) {
      Expression _arr = ((ArrayAccess)E).getArr();
      final Var arr = ((Var) _arr);
      final String varname = arr.getValor().getName();
      Definition _valor = arr.getValor();
      final VarDecl decl = ((VarDecl) _valor);
      final String tipo = decl.getTipo().getTipo();
      StringConcatenation _builder_4 = new StringConcatenation();
      String id_2 = _builder_4.toString();
      StringConcatenation _builder_5 = new StringConcatenation();
      String idx = _builder_5.toString();
      Expression _index = ((ArrayAccess)E).getIndex();
      if ((_index instanceof IntLit)) {
        StringConcatenation _builder_6 = new StringConcatenation();
        _builder_6.append("+");
        Expression _index_1 = ((ArrayAccess)E).getIndex();
        int _val = ((IntLit) _index_1).getVal();
        int _multiply = (_val * 4);
        _builder_6.append(_multiply);
        idx = _builder_6.toString();
        String _reference = this.getReference(varname);
        String _plus = (_reference + idx);
        id_2 = _plus;
      } else {
        String _mips_15 = mips;
        StringConcatenation _builder_7 = new StringConcatenation();
        CharSequence _expression_1 = this.expression(((ArrayAccess)E).getIndex());
        _builder_7.append(_expression_1);
        _builder_7.newLineIfNotEmpty();
        CharSequence _pop_1 = this.pop("t5");
        _builder_7.append(_pop_1);
        _builder_7.newLineIfNotEmpty();
        _builder_7.append("la\t\t$t6, ");
        String _reference_1 = this.getReference(varname);
        _builder_7.append(_reference_1);
        _builder_7.newLineIfNotEmpty();
        _builder_7.append("sll\t\t$t5, $t5, 2");
        _builder_7.newLine();
        _builder_7.append("add\t\t$t5, $t6, $t5");
        _builder_7.newLine();
        _builder_7.newLine();
        mips = (_mips_15 + _builder_7);
        StringConcatenation _builder_8 = new StringConcatenation();
        _builder_8.append("0($t5)");
        id_2 = _builder_8.toString();
      }
      String _xifexpression_1 = null;
      if ((Objects.equal(tipo, "string") && this.globals.contains(varname))) {
        _xifexpression_1 = "la";
      } else {
        _xifexpression_1 = "lw";
      }
      final String opCode = _xifexpression_1;
      String _mips_16 = mips;
      CharSequence _evalExp = this.evalExp(opCode, id_2);
      mips = (_mips_16 + _evalExp);
      return mips;
    }
    if ((E instanceof Var)) {
      final String varname_1 = ((Var)E).getValor().getName();
      Definition _valor_1 = ((Var)E).getValor();
      final VarDecl decl_1 = ((VarDecl) _valor_1);
      final String tipo_1 = decl_1.getTipo().getTipo();
      String _xifexpression_2 = null;
      if ((Objects.equal(tipo_1, "string") && this.globals.contains(varname_1))) {
        _xifexpression_2 = "la";
      } else {
        _xifexpression_2 = "lw";
      }
      String opCode_1 = _xifexpression_2;
      String _xifexpression_3 = null;
      boolean _containsKey = this.params.containsKey(varname_1);
      if (_containsKey) {
        _xifexpression_3 = "move";
      } else {
        _xifexpression_3 = opCode_1;
      }
      opCode_1 = _xifexpression_3;
      final String id_3 = this.getReference(varname_1);
      String _mips_17 = mips;
      CharSequence _evalExp_1 = this.evalExp(opCode_1, id_3);
      mips = (_mips_17 + _evalExp_1);
      return mips;
    }
    if ((E instanceof IntLit)) {
      final int valor = ((IntLit)E).getVal();
      String _mips_18 = mips;
      CharSequence _evalExp_2 = this.evalExp("li", Integer.valueOf(valor).toString());
      mips = (_mips_18 + _evalExp_2);
      return mips;
    }
    if ((E instanceof TrueLit)) {
      String _mips_19 = mips;
      CharSequence _evalExp_3 = this.evalExp("li", "1");
      mips = (_mips_19 + _evalExp_3);
      return mips;
    }
    if ((E instanceof FalseLit)) {
      String _mips_20 = mips;
      CharSequence _evalExp_4 = this.evalExp("li", "0");
      mips = (_mips_20 + _evalExp_4);
      return mips;
    }
    if ((E instanceof StrLit)) {
      String _nextLabel = this.nextLabel();
      final String strLabel = ("S" + _nextLabel);
      String _mips_21 = mips;
      String _storeString = this.storeString(((StrLit)E), strLabel);
      mips = (_mips_21 + _storeString);
      return mips;
    }
    if ((E instanceof FieldAccess)) {
    }
    if ((E instanceof PointerExp)) {
    }
    return mips;
  }
  
  public String arithExp(final ArithExp E, final String opCode) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _expression = this.expression(E.getArgs().get(0));
    _builder.append(_expression);
    _builder.newLineIfNotEmpty();
    CharSequence _expression_1 = this.expression(E.getArgs().get(1));
    _builder.append(_expression_1);
    _builder.newLineIfNotEmpty();
    CharSequence _pop = this.pop("t1");
    _builder.append(_pop);
    _builder.newLineIfNotEmpty();
    CharSequence _pop_1 = this.pop("t0");
    _builder.append(_pop_1);
    _builder.newLineIfNotEmpty();
    _builder.append(opCode);
    _builder.append("\t\t$t0, $t0, $t1");
    _builder.newLineIfNotEmpty();
    CharSequence _push = this.push("t0");
    _builder.append(_push);
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    String mips = _builder.toString();
    return mips;
  }
  
  public String logicExp(final LogicExp E, final String opCode) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _expression = this.expression(E.getArgs().get(0));
    _builder.append(_expression);
    _builder.newLineIfNotEmpty();
    CharSequence _expression_1 = this.expression(E.getArgs().get(1));
    _builder.append(_expression_1);
    _builder.newLineIfNotEmpty();
    CharSequence _pop = this.pop("t1");
    _builder.append(_pop);
    _builder.newLineIfNotEmpty();
    CharSequence _pop_1 = this.pop("t0");
    _builder.append(_pop_1);
    _builder.newLineIfNotEmpty();
    _builder.append(opCode);
    _builder.append("\t\t$t0, $t0, $t1");
    _builder.newLineIfNotEmpty();
    CharSequence _push = this.push("t0");
    _builder.append(_push);
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    String mips = _builder.toString();
    return mips;
  }
  
  public String termExp(final Term E, final String opCode) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _expression = this.expression(E.getArgs().get(0));
    _builder.append(_expression);
    _builder.newLineIfNotEmpty();
    CharSequence _expression_1 = this.expression(E.getArgs().get(1));
    _builder.append(_expression_1);
    _builder.newLineIfNotEmpty();
    CharSequence _pop = this.pop("t1");
    _builder.append(_pop);
    _builder.newLineIfNotEmpty();
    CharSequence _pop_1 = this.pop("t0");
    _builder.append(_pop_1);
    _builder.newLineIfNotEmpty();
    _builder.append(opCode);
    _builder.append("\t\t$t0, $t0, $t1");
    _builder.newLineIfNotEmpty();
    CharSequence _push = this.push("t0");
    _builder.append(_push);
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    String mips = _builder.toString();
    return mips;
  }
  
  public String relExp(final RelExp E, final String opCode) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _expression = this.expression(E.getArgs().get(0));
    _builder.append(_expression);
    _builder.newLineIfNotEmpty();
    CharSequence _expression_1 = this.expression(E.getArgs().get(1));
    _builder.append(_expression_1);
    _builder.newLineIfNotEmpty();
    CharSequence _pop = this.pop("t1");
    _builder.append(_pop);
    _builder.newLineIfNotEmpty();
    CharSequence _pop_1 = this.pop("t0");
    _builder.append(_pop_1);
    _builder.newLineIfNotEmpty();
    _builder.append(opCode);
    _builder.append("\t\t$t0, $t0, $t1");
    _builder.newLineIfNotEmpty();
    CharSequence _push = this.push("t0");
    _builder.append(_push);
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    String mips = _builder.toString();
    return mips;
  }
  
  public CharSequence functionEntry(final int paramSize, final int localSize) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("sw\t \t$ra, 0($sp)");
    _builder.newLine();
    _builder.append("addiu \t$sp, $sp, -4");
    _builder.newLine();
    _builder.append("sw   \t$fp, 0($sp)");
    _builder.newLine();
    _builder.append("addiu\t$sp, $sp, -4");
    _builder.newLine();
    _builder.append("addiu \t$fp, $sp, ");
    _builder.append((paramSize + 8));
    _builder.newLineIfNotEmpty();
    _builder.append("addiu \t$sp, $sp, -");
    _builder.append(localSize);
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence functionExit(final int paramSize) {
    StringConcatenation _builder = new StringConcatenation();
    String _pop = this.fName.pop();
    _builder.append(_pop);
    _builder.append("_return:");
    _builder.newLineIfNotEmpty();
    _builder.append("  ");
    _builder.append("lw   $ra, -");
    _builder.append(paramSize, "  ");
    _builder.append("($fp)");
    _builder.newLineIfNotEmpty();
    _builder.append("  ");
    _builder.append("move $t0, $fp");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("lw   $fp, -");
    _builder.append((paramSize + 4), "  ");
    _builder.append("($fp)");
    _builder.newLineIfNotEmpty();
    _builder.append("  ");
    _builder.append("move $sp, $t0");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("jr   $ra");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence jumpLink(final String func) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("jal ");
    _builder.append(func);
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence store(final Expression E) {
    final Var varexp = ((Var) E);
    final String varname = varexp.getValor().getName();
    StringConcatenation _builder = new StringConcatenation();
    String mips = _builder.toString();
    boolean _containsKey = this.locals.containsKey(varname);
    if (_containsKey) {
      String _mips = mips;
      StringConcatenation _builder_1 = new StringConcatenation();
      CharSequence _pop = this.pop("t7");
      _builder_1.append(_pop);
      _builder_1.newLineIfNotEmpty();
      CharSequence _indexed = this.indexed("sw", "t7", (this.locals.get(varname)).intValue(), "fp");
      _builder_1.append(_indexed);
      _builder_1.newLineIfNotEmpty();
      _builder_1.newLine();
      mips = (_mips + _builder_1);
      return mips;
    }
    boolean _contains = this.globals.contains(varname);
    if (_contains) {
      String _mips_1 = mips;
      StringConcatenation _builder_2 = new StringConcatenation();
      CharSequence _pop_1 = this.pop("t9");
      _builder_2.append(_pop_1);
      _builder_2.newLineIfNotEmpty();
      _builder_2.append("sw\t\t$t9, _");
      _builder_2.append(varname);
      _builder_2.newLineIfNotEmpty();
      _builder_2.newLine();
      mips = (_mips_1 + _builder_2);
      return mips;
    }
    return mips;
  }
  
  public String storeArray(final ArrayAccess A) {
    StringConcatenation _builder = new StringConcatenation();
    String mips = _builder.toString();
    Expression _arr = A.getArr();
    final String varname = ((Var) _arr).getValor().getName();
    Expression _index = A.getIndex();
    int _val = ((IntLit) _index).getVal();
    final int arrIdx = (_val * 4);
    boolean _containsKey = this.locals.containsKey(varname);
    if (_containsKey) {
      String _mips = mips;
      StringConcatenation _builder_1 = new StringConcatenation();
      CharSequence _pop = this.pop("t7");
      _builder_1.append(_pop);
      _builder_1.newLineIfNotEmpty();
      CharSequence _indexed = this.indexed("sw", "t7", (this.locals.get(varname)).intValue(), "fp");
      _builder_1.append(_indexed);
      _builder_1.newLineIfNotEmpty();
      _builder_1.newLine();
      mips = (_mips + _builder_1);
      return mips;
    }
    boolean _contains = this.globals.contains(varname);
    if (_contains) {
      String _mips_1 = mips;
      StringConcatenation _builder_2 = new StringConcatenation();
      CharSequence _pop_1 = this.pop("t9");
      _builder_2.append(_pop_1);
      _builder_2.newLineIfNotEmpty();
      _builder_2.append("sw\t\t$t9, _");
      _builder_2.append(varname);
      _builder_2.append("+");
      _builder_2.append(arrIdx);
      _builder_2.newLineIfNotEmpty();
      _builder_2.newLine();
      mips = (_mips_1 + _builder_2);
      return mips;
    }
    return mips;
  }
  
  public String storeString(final StrLit E, final String strLabel) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(".data");
    _builder.newLine();
    _builder.append("_");
    _builder.append(strLabel);
    _builder.append(": .asciiz \"");
    String _val = E.getVal();
    _builder.append(_val);
    _builder.append("\"");
    _builder.newLineIfNotEmpty();
    _builder.append(".text");
    _builder.newLine();
    CharSequence _evalExp = this.evalExp("la", ("_" + strLabel));
    _builder.append(_evalExp);
    _builder.newLineIfNotEmpty();
    String mips = _builder.toString();
    return mips;
  }
  
  public CharSequence evalExp(final String opCode, final String value) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(opCode);
    _builder.append("\t\t$t8, ");
    _builder.append(value);
    _builder.newLineIfNotEmpty();
    CharSequence _push = this.push("t8");
    _builder.append(_push);
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    String mips = _builder.toString();
    return mips;
  }
  
  public CharSequence push(final String reg) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("addiu\t$sp, $sp, -4");
    _builder.newLine();
    _builder.append("sw\t\t$");
    _builder.append(reg);
    _builder.append(", ($sp)");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence pop(final String reg) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("lw \t\t$");
    _builder.append(reg);
    _builder.append(", ($sp)");
    _builder.newLineIfNotEmpty();
    _builder.append("addiu\t$sp, $sp, 4");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence indexed(final String opCode, final String reg1, final int offset, final String reg2) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(opCode);
    _builder.append("\t\t$");
    _builder.append(reg1);
    _builder.append(", -");
    _builder.append((offset + 4));
    _builder.append("($");
    _builder.append(reg2);
    _builder.append(")");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public String getReference(final String varname) {
    boolean _containsKey = this.params.containsKey(varname);
    if (_containsKey) {
      Integer _get = this.params.get(varname);
      return ("$a" + _get);
    }
    boolean _containsKey_1 = this.locals.containsKey(varname);
    if (_containsKey_1) {
      Integer _get_1 = this.locals.get(varname);
      int _plus = ((_get_1).intValue() + 4);
      String _plus_1 = ("-" + Integer.valueOf(_plus));
      return (_plus_1 + "($fp)");
    }
    return ("_" + varname);
  }
  
  public int getParamSize(final EList<Declaration> decs) {
    int size = 0;
    int argNum = 0;
    for (final Declaration d : decs) {
      {
        final Type tipo = ((VarDecl) d).getTipo();
        final String paramName = ((VarDecl) d).getName();
        int paramSize = 0;
        Expression _exp = tipo.getExp();
        boolean _tripleNotEquals = (_exp != null);
        if (_tripleNotEquals) {
          Expression _exp_1 = tipo.getExp();
          int _val = ((IntLit) _exp_1).getVal();
          int _multiply = (_val * 4);
          paramSize = _multiply;
        } else {
          paramSize = 4;
        }
        this.params.put(paramName, Integer.valueOf(argNum));
        argNum++;
        int _size = size;
        size = (_size + paramSize);
      }
    }
    return size;
  }
  
  public String nextLabel() {
    this.label++;
    return ("L" + Integer.valueOf(this.label));
  }
  
  public Stack<String> orderStack(final Stack<String> s) {
    Stack<String> ordered = new Stack<String>();
    while ((!s.empty())) {
      ordered.push(s.pop());
    }
    return ordered;
  }
}
