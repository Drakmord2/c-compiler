/*
 * generated by Xtext 2.12.0
 */
package com.poli.compilador.validation

import com.poli.compilador.c.ArrayAccess
import com.poli.compilador.c.CPackage
import com.poli.compilador.c.DoWhileCmd
import com.poli.compilador.c.Expression
import com.poli.compilador.c.FieldAccess
import com.poli.compilador.c.ForCmd
import com.poli.compilador.c.IfCmd
import com.poli.compilador.c.StrDecl
import com.poli.compilador.c.SwitchCmd
import com.poli.compilador.c.Var
import com.poli.compilador.c.WhileCmd
import org.eclipse.xtext.validation.Check
import com.poli.compilador.c.Declaration
import com.poli.compilador.c.VarDecl
import com.poli.compilador.c.IntLit
import com.poli.compilador.c.Literal

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class CValidator extends AbstractCValidator {
	
	@Check
	def checkIf (IfCmd c) {
		val tipo = Validator.tipode(c.exp, null)
		
		if ( tipo != Validator.Tipo.BOOL) {
			error('Condition must be a Bool. '+tipo+' given.', c, CPackage.Literals.IF_CMD__EXP)
		}  
	} 
	
	@Check
	def checkWhile (WhileCmd c) {
		val tipo = Validator.tipode(c.exp, null)
		
		if ( tipo != Validator.Tipo.BOOL) {
			error('Condition must be a Bool. '+tipo+' given.', c, CPackage.Literals.WHILE_CMD__EXP)
		}  
	}
	
	@Check
	def checkDoWhile (DoWhileCmd c) {
		val tipo = Validator.tipode(c.exp, null)
		
		if ( tipo != Validator.Tipo.BOOL) {
			error('Condition must be a Bool. '+tipo+' given.', c, CPackage.Literals.DO_WHILE_CMD__EXP)
		}  
	}
	
	@Check
	def checkSwitch (SwitchCmd c) {
		val tipo = Validator.tipode(c.exp, null)
		
		if ( tipo === null) {
			error('Invalid switch expression. ', c, CPackage.Literals.SWITCH_CMD__EXP)
		}  
		
		for(cs: c.cases) {
			var tipoCase = Validator.tipode(cs.^val, null)
			
			if (tipoCase != tipo) {
				error('Invalid case type. ', c, CPackage.Literals.SWITCH_CMD__CASES)
			}
			
			if (cs.^val instanceof Literal != true) {
				error('Invalid case. ', c, CPackage.Literals.SWITCH_CMD__CASES)
			}
		}
		
	}
	
	@Check
	def checkFor (ForCmd c) {
		val tipo = Validator.tipode(c.exp, null)
		
		if ( tipo != Validator.Tipo.BOOL) {
			error('Condition must be a Bool. '+tipo+' given.', c, CPackage.Literals.FOR_CMD__EXP)
		} 
	}
	
	@Check
	def checkAccess (Expression v) {
		if (v instanceof FieldAccess ) {
			val lvalue 	= v.obj as Var
			
			if (lvalue.valor instanceof StrDecl != true) {
				error('Illegal access. Not a Struct.', v, CPackage.Literals.FIELD_ACCESS__OBJ)
				return
			}
			
			val strDecl	= lvalue.valor as StrDecl
			val struct 	= strDecl.str
			val decls	= struct.decl
			val campo 	= v.field
			
			for (d : decls) {
				if (d.name == campo) {
					return
				}
			}
			
			error('Struct field not defined.', v, CPackage.Literals.FIELD_ACCESS__FIELD)
		}
		
		if (v instanceof ArrayAccess) {
			val lvalue 	= v.arr as Var
			
			if (lvalue.valor instanceof Declaration != true) {
				return
			}
			
			val decl = lvalue.valor as Declaration
			
			if (decl instanceof VarDecl != true) {
				error('Illegal access. Not a variable.', v, CPackage.Literals.ARRAY_ACCESS__ARR)
				return
			}
			
			val tipo = (decl as VarDecl).tipo
			if (tipo.exp === null) {
				error('Illegal access. Not an Array.', v, CPackage.Literals.ARRAY_ACCESS__INDEX)
				return
			}
			
			val index = v.index
			if (Validator.tipode(index, null) != Validator.Tipo.INT) {
				error('Illegal access. Non integer index.', v, CPackage.Literals.ARRAY_ACCESS__INDEX)
				return
			}
			
			if (index instanceof Var) {
				return
			}
			
			if ( (tipo.exp as IntLit).^val < ((index as IntLit).^val + 1) || (index as IntLit).^val < 0) {
				error('Array out of bounds.', v, CPackage.Literals.ARRAY_ACCESS__INDEX)
				return
			}
			
		}
	}
	
}
